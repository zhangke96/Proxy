// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Message;
class Head;
class Body;
class ResponseCode;
class ListenRequest;
class ListenResponse;
class Ping;
class Pong;
class LogoutRequest;
class LogoutResponse;
class NewConnectionRequest;
class NewConnectionResponse;
class CloseConnectionRequest;
class CloseConnectionResponse;
class DataRequest;
class DataResponse;

enum MessageType {
  LISTEN_REQUEST = 1,
  LISTEN_RESPONSE = 2,
  PING = 3,
  PONG = 4,
  LOGOUT_REQUEST = 5,
  LOGOUT_RESPONSE = 6,
  NEW_CONNECTION_REQUEST = 7,
  NEW_CONNECTION_RESPONSE = 8,
  CLOSE_CONNECTION_REQUEST = 9,
  CLOSE_CONNECTION_RESONSE = 10,
  DATA_REQUEST = 11,
  DATA_RESPONSE = 12
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = LISTEN_REQUEST;
const MessageType MessageType_MAX = DATA_RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(MessageType_descriptor(),
                                                  value);
}
inline bool MessageType_Parse(const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.Head head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::proto::Head& head() const;
  inline ::proto::Head* mutable_head();
  inline ::proto::Head* release_head();
  inline void set_allocated_head(::proto::Head* head);

  // required .proto.Body body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::proto::Body& body() const;
  inline ::proto::Body* mutable_body();
  inline ::proto::Body* release_body();
  inline void set_allocated_body(::proto::Body* body);

  // @@protoc_insertion_point(class_scope:proto.Message)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::Head* head_;
  ::proto::Body* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Head : public ::google::protobuf::Message {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();

  void Swap(Head* other);

  // implements Message ----------------------------------------------

  Head* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required uint32 random_num = 2;
  inline bool has_random_num() const;
  inline void clear_random_num();
  static const int kRandomNumFieldNumber = 2;
  inline ::google::protobuf::uint32 random_num() const;
  inline void set_random_num(::google::protobuf::uint32 value);

  // required uint32 flow_no = 3;
  inline bool has_flow_no() const;
  inline void clear_flow_no();
  static const int kFlowNoFieldNumber = 3;
  inline ::google::protobuf::uint32 flow_no() const;
  inline void set_flow_no(::google::protobuf::uint32 value);

  // required int32 message_type = 4;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 4;
  inline ::google::protobuf::int32 message_type() const;
  inline void set_message_type(::google::protobuf::int32 value);

  // required uint32 source_entity = 5;
  inline bool has_source_entity() const;
  inline void clear_source_entity();
  static const int kSourceEntityFieldNumber = 5;
  inline ::google::protobuf::uint32 source_entity() const;
  inline void set_source_entity(::google::protobuf::uint32 value);

  // optional uint32 dest_entity = 6;
  inline bool has_dest_entity() const;
  inline void clear_dest_entity();
  static const int kDestEntityFieldNumber = 6;
  inline ::google::protobuf::uint32 dest_entity() const;
  inline void set_dest_entity(::google::protobuf::uint32 value);

  // optional string call_purpose = 7;
  inline bool has_call_purpose() const;
  inline void clear_call_purpose();
  static const int kCallPurposeFieldNumber = 7;
  inline const ::std::string& call_purpose() const;
  inline void set_call_purpose(const ::std::string& value);
  inline void set_call_purpose(const char* value);
  inline void set_call_purpose(const char* value, size_t size);
  inline ::std::string* mutable_call_purpose();
  inline ::std::string* release_call_purpose();
  inline void set_allocated_call_purpose(::std::string* call_purpose);

  // optional string auth_key = 8;
  inline bool has_auth_key() const;
  inline void clear_auth_key();
  static const int kAuthKeyFieldNumber = 8;
  inline const ::std::string& auth_key() const;
  inline void set_auth_key(const ::std::string& value);
  inline void set_auth_key(const char* value);
  inline void set_auth_key(const char* value, size_t size);
  inline ::std::string* mutable_auth_key();
  inline ::std::string* release_auth_key();
  inline void set_allocated_auth_key(::std::string* auth_key);

  // optional uint64 session_key = 9;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 9;
  inline ::google::protobuf::uint64 session_key() const;
  inline void set_session_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Head)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_num();
  inline void clear_has_random_num();
  inline void set_has_flow_no();
  inline void clear_has_flow_no();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_source_entity();
  inline void clear_has_source_entity();
  inline void set_has_dest_entity();
  inline void clear_has_dest_entity();
  inline void set_has_call_purpose();
  inline void clear_has_call_purpose();
  inline void set_has_auth_key();
  inline void clear_has_auth_key();
  inline void set_has_session_key();
  inline void clear_has_session_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 random_num_;
  ::google::protobuf::uint32 flow_no_;
  ::google::protobuf::int32 message_type_;
  ::google::protobuf::uint32 source_entity_;
  ::google::protobuf::uint32 dest_entity_;
  ::std::string* call_purpose_;
  ::std::string* auth_key_;
  ::google::protobuf::uint64 session_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class Body : public ::google::protobuf::Message {
 public:
  Body();
  virtual ~Body();

  Body(const Body& from);

  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Body& default_instance();

  void Swap(Body* other);

  // implements Message ----------------------------------------------

  Body* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Body& from);
  void MergeFrom(const Body& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ListenRequest listen_request = 1;
  inline bool has_listen_request() const;
  inline void clear_listen_request();
  static const int kListenRequestFieldNumber = 1;
  inline const ::proto::ListenRequest& listen_request() const;
  inline ::proto::ListenRequest* mutable_listen_request();
  inline ::proto::ListenRequest* release_listen_request();
  inline void set_allocated_listen_request(
      ::proto::ListenRequest* listen_request);

  // optional .proto.ListenResponse listen_response = 2;
  inline bool has_listen_response() const;
  inline void clear_listen_response();
  static const int kListenResponseFieldNumber = 2;
  inline const ::proto::ListenResponse& listen_response() const;
  inline ::proto::ListenResponse* mutable_listen_response();
  inline ::proto::ListenResponse* release_listen_response();
  inline void set_allocated_listen_response(
      ::proto::ListenResponse* listen_response);

  // optional .proto.Ping ping = 3;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 3;
  inline const ::proto::Ping& ping() const;
  inline ::proto::Ping* mutable_ping();
  inline ::proto::Ping* release_ping();
  inline void set_allocated_ping(::proto::Ping* ping);

  // optional .proto.Pong pong = 4;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 4;
  inline const ::proto::Pong& pong() const;
  inline ::proto::Pong* mutable_pong();
  inline ::proto::Pong* release_pong();
  inline void set_allocated_pong(::proto::Pong* pong);

  // optional .proto.LogoutRequest logout_request = 5;
  inline bool has_logout_request() const;
  inline void clear_logout_request();
  static const int kLogoutRequestFieldNumber = 5;
  inline const ::proto::LogoutRequest& logout_request() const;
  inline ::proto::LogoutRequest* mutable_logout_request();
  inline ::proto::LogoutRequest* release_logout_request();
  inline void set_allocated_logout_request(
      ::proto::LogoutRequest* logout_request);

  // optional .proto.LogoutResponse logout_response = 6;
  inline bool has_logout_response() const;
  inline void clear_logout_response();
  static const int kLogoutResponseFieldNumber = 6;
  inline const ::proto::LogoutResponse& logout_response() const;
  inline ::proto::LogoutResponse* mutable_logout_response();
  inline ::proto::LogoutResponse* release_logout_response();
  inline void set_allocated_logout_response(
      ::proto::LogoutResponse* logout_response);

  // optional .proto.NewConnectionRequest new_connection_request = 7;
  inline bool has_new_connection_request() const;
  inline void clear_new_connection_request();
  static const int kNewConnectionRequestFieldNumber = 7;
  inline const ::proto::NewConnectionRequest& new_connection_request() const;
  inline ::proto::NewConnectionRequest* mutable_new_connection_request();
  inline ::proto::NewConnectionRequest* release_new_connection_request();
  inline void set_allocated_new_connection_request(
      ::proto::NewConnectionRequest* new_connection_request);

  // optional .proto.NewConnectionResponse new_connection_response = 8;
  inline bool has_new_connection_response() const;
  inline void clear_new_connection_response();
  static const int kNewConnectionResponseFieldNumber = 8;
  inline const ::proto::NewConnectionResponse& new_connection_response() const;
  inline ::proto::NewConnectionResponse* mutable_new_connection_response();
  inline ::proto::NewConnectionResponse* release_new_connection_response();
  inline void set_allocated_new_connection_response(
      ::proto::NewConnectionResponse* new_connection_response);

  // optional .proto.CloseConnectionRequest close_connection_request = 9;
  inline bool has_close_connection_request() const;
  inline void clear_close_connection_request();
  static const int kCloseConnectionRequestFieldNumber = 9;
  inline const ::proto::CloseConnectionRequest& close_connection_request()
      const;
  inline ::proto::CloseConnectionRequest* mutable_close_connection_request();
  inline ::proto::CloseConnectionRequest* release_close_connection_request();
  inline void set_allocated_close_connection_request(
      ::proto::CloseConnectionRequest* close_connection_request);

  // optional .proto.CloseConnectionResponse close_connection_response = 10;
  inline bool has_close_connection_response() const;
  inline void clear_close_connection_response();
  static const int kCloseConnectionResponseFieldNumber = 10;
  inline const ::proto::CloseConnectionResponse& close_connection_response()
      const;
  inline ::proto::CloseConnectionResponse* mutable_close_connection_response();
  inline ::proto::CloseConnectionResponse* release_close_connection_response();
  inline void set_allocated_close_connection_response(
      ::proto::CloseConnectionResponse* close_connection_response);

  // optional .proto.DataRequest data_request = 11;
  inline bool has_data_request() const;
  inline void clear_data_request();
  static const int kDataRequestFieldNumber = 11;
  inline const ::proto::DataRequest& data_request() const;
  inline ::proto::DataRequest* mutable_data_request();
  inline ::proto::DataRequest* release_data_request();
  inline void set_allocated_data_request(::proto::DataRequest* data_request);

  // optional .proto.DataResponse data_response = 12;
  inline bool has_data_response() const;
  inline void clear_data_response();
  static const int kDataResponseFieldNumber = 12;
  inline const ::proto::DataResponse& data_response() const;
  inline ::proto::DataResponse* mutable_data_response();
  inline ::proto::DataResponse* release_data_response();
  inline void set_allocated_data_response(::proto::DataResponse* data_response);

  // @@protoc_insertion_point(class_scope:proto.Body)
 private:
  inline void set_has_listen_request();
  inline void clear_has_listen_request();
  inline void set_has_listen_response();
  inline void clear_has_listen_response();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_pong();
  inline void clear_has_pong();
  inline void set_has_logout_request();
  inline void clear_has_logout_request();
  inline void set_has_logout_response();
  inline void clear_has_logout_response();
  inline void set_has_new_connection_request();
  inline void clear_has_new_connection_request();
  inline void set_has_new_connection_response();
  inline void clear_has_new_connection_response();
  inline void set_has_close_connection_request();
  inline void clear_has_close_connection_request();
  inline void set_has_close_connection_response();
  inline void clear_has_close_connection_response();
  inline void set_has_data_request();
  inline void clear_has_data_request();
  inline void set_has_data_response();
  inline void clear_has_data_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ListenRequest* listen_request_;
  ::proto::ListenResponse* listen_response_;
  ::proto::Ping* ping_;
  ::proto::Pong* pong_;
  ::proto::LogoutRequest* logout_request_;
  ::proto::LogoutResponse* logout_response_;
  ::proto::NewConnectionRequest* new_connection_request_;
  ::proto::NewConnectionResponse* new_connection_response_;
  ::proto::CloseConnectionRequest* close_connection_request_;
  ::proto::CloseConnectionResponse* close_connection_response_;
  ::proto::DataRequest* data_request_;
  ::proto::DataResponse* data_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Body* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCode : public ::google::protobuf::Message {
 public:
  ResponseCode();
  virtual ~ResponseCode();

  ResponseCode(const ResponseCode& from);

  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCode& default_instance();

  void Swap(ResponseCode* other);

  // implements Message ----------------------------------------------

  ResponseCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:proto.ResponseCode)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_message_;
  ::google::protobuf::int32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ResponseCode* default_instance_;
};
// -------------------------------------------------------------------

class ListenRequest : public ::google::protobuf::Message {
 public:
  ListenRequest();
  virtual ~ListenRequest();

  ListenRequest(const ListenRequest& from);

  inline ListenRequest& operator=(const ListenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenRequest& default_instance();

  void Swap(ListenRequest* other);

  // implements Message ----------------------------------------------

  ListenRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListenRequest& from);
  void MergeFrom(const ListenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 self_ipv4 = 1;
  inline bool has_self_ipv4() const;
  inline void clear_self_ipv4();
  static const int kSelfIpv4FieldNumber = 1;
  inline ::google::protobuf::uint32 self_ipv4() const;
  inline void set_self_ipv4(::google::protobuf::uint32 value);

  // repeated bytes self_ipv6 = 2;
  inline int self_ipv6_size() const;
  inline void clear_self_ipv6();
  static const int kSelfIpv6FieldNumber = 2;
  inline const ::std::string& self_ipv6(int index) const;
  inline ::std::string* mutable_self_ipv6(int index);
  inline void set_self_ipv6(int index, const ::std::string& value);
  inline void set_self_ipv6(int index, const char* value);
  inline void set_self_ipv6(int index, const void* value, size_t size);
  inline ::std::string* add_self_ipv6();
  inline void add_self_ipv6(const ::std::string& value);
  inline void add_self_ipv6(const char* value);
  inline void add_self_ipv6(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& self_ipv6()
      const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>*
  mutable_self_ipv6();

  // required uint32 self_port = 3;
  inline bool has_self_port() const;
  inline void clear_self_port();
  static const int kSelfPortFieldNumber = 3;
  inline ::google::protobuf::uint32 self_port() const;
  inline void set_self_port(::google::protobuf::uint32 value);

  // required uint32 listen_port = 4;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 4;
  inline ::google::protobuf::uint32 listen_port() const;
  inline void set_listen_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.ListenRequest)
 private:
  inline void set_has_self_ipv4();
  inline void clear_has_self_ipv4();
  inline void set_has_self_port();
  inline void clear_has_self_port();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> self_ipv6_;
  ::google::protobuf::uint32 self_ipv4_;
  ::google::protobuf::uint32 self_port_;
  ::google::protobuf::uint32 listen_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ListenRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListenResponse : public ::google::protobuf::Message {
 public:
  ListenResponse();
  virtual ~ListenResponse();

  ListenResponse(const ListenResponse& from);

  inline ListenResponse& operator=(const ListenResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenResponse& default_instance();

  void Swap(ListenResponse* other);

  // implements Message ----------------------------------------------

  ListenResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListenResponse& from);
  void MergeFrom(const ListenResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::proto::ResponseCode& rc() const;
  inline ::proto::ResponseCode* mutable_rc();
  inline ::proto::ResponseCode* release_rc();
  inline void set_allocated_rc(::proto::ResponseCode* rc);

  // optional uint64 session_key = 2;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 session_key() const;
  inline void set_session_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.ListenResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();
  inline void set_has_session_key();
  inline void clear_has_session_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ResponseCode* rc_;
  ::google::protobuf::uint64 session_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ListenResponse* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ping)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  Pong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::proto::ResponseCode& rc() const;
  inline ::proto::ResponseCode* mutable_rc();
  inline ::proto::ResponseCode* release_rc();
  inline void set_allocated_rc(::proto::ResponseCode* rc);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Pong)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ResponseCode* rc_;
  ::google::protobuf::uint64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Pong* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();

  void Swap(LogoutRequest* other);

  // implements Message ----------------------------------------------

  LogoutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.LogoutRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResponse : public ::google::protobuf::Message {
 public:
  LogoutResponse();
  virtual ~LogoutResponse();

  LogoutResponse(const LogoutResponse& from);

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponse& default_instance();

  void Swap(LogoutResponse* other);

  // implements Message ----------------------------------------------

  LogoutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResponse& from);
  void MergeFrom(const LogoutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::proto::ResponseCode& rc() const;
  inline ::proto::ResponseCode* mutable_rc();
  inline ::proto::ResponseCode* release_rc();
  inline void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.LogoutResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ResponseCode* rc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static LogoutResponse* default_instance_;
};
// -------------------------------------------------------------------

class NewConnectionRequest : public ::google::protobuf::Message {
 public:
  NewConnectionRequest();
  virtual ~NewConnectionRequest();

  NewConnectionRequest(const NewConnectionRequest& from);

  inline NewConnectionRequest& operator=(const NewConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewConnectionRequest& default_instance();

  void Swap(NewConnectionRequest* other);

  // implements Message ----------------------------------------------

  NewConnectionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewConnectionRequest& from);
  void MergeFrom(const NewConnectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ip_v4 = 1;
  inline bool has_ip_v4() const;
  inline void clear_ip_v4();
  static const int kIpV4FieldNumber = 1;
  inline ::google::protobuf::uint32 ip_v4() const;
  inline void set_ip_v4(::google::protobuf::uint32 value);

  // repeated bytes ip_v6 = 2;
  inline int ip_v6_size() const;
  inline void clear_ip_v6();
  static const int kIpV6FieldNumber = 2;
  inline const ::std::string& ip_v6(int index) const;
  inline ::std::string* mutable_ip_v6(int index);
  inline void set_ip_v6(int index, const ::std::string& value);
  inline void set_ip_v6(int index, const char* value);
  inline void set_ip_v6(int index, const void* value, size_t size);
  inline ::std::string* add_ip_v6();
  inline void add_ip_v6(const ::std::string& value);
  inline void add_ip_v6(const char* value);
  inline void add_ip_v6(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_v6()
      const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_v6();

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint64 conn_key = 4;
  inline bool has_conn_key() const;
  inline void clear_conn_key();
  static const int kConnKeyFieldNumber = 4;
  inline ::google::protobuf::uint64 conn_key() const;
  inline void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.NewConnectionRequest)
 private:
  inline void set_has_ip_v4();
  inline void clear_has_ip_v4();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_conn_key();
  inline void clear_has_conn_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> ip_v6_;
  ::google::protobuf::uint32 ip_v4_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 conn_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static NewConnectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class NewConnectionResponse : public ::google::protobuf::Message {
 public:
  NewConnectionResponse();
  virtual ~NewConnectionResponse();

  NewConnectionResponse(const NewConnectionResponse& from);

  inline NewConnectionResponse& operator=(const NewConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewConnectionResponse& default_instance();

  void Swap(NewConnectionResponse* other);

  // implements Message ----------------------------------------------

  NewConnectionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewConnectionResponse& from);
  void MergeFrom(const NewConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::proto::ResponseCode& rc() const;
  inline ::proto::ResponseCode* mutable_rc();
  inline ::proto::ResponseCode* release_rc();
  inline void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.NewConnectionResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ResponseCode* rc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static NewConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class CloseConnectionRequest : public ::google::protobuf::Message {
 public:
  CloseConnectionRequest();
  virtual ~CloseConnectionRequest();

  CloseConnectionRequest(const CloseConnectionRequest& from);

  inline CloseConnectionRequest& operator=(const CloseConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseConnectionRequest& default_instance();

  void Swap(CloseConnectionRequest* other);

  // implements Message ----------------------------------------------

  CloseConnectionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseConnectionRequest& from);
  void MergeFrom(const CloseConnectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 conn_key = 1;
  inline bool has_conn_key() const;
  inline void clear_conn_key();
  static const int kConnKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 conn_key() const;
  inline void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.CloseConnectionRequest)
 private:
  inline void set_has_conn_key();
  inline void clear_has_conn_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 conn_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static CloseConnectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CloseConnectionResponse : public ::google::protobuf::Message {
 public:
  CloseConnectionResponse();
  virtual ~CloseConnectionResponse();

  CloseConnectionResponse(const CloseConnectionResponse& from);

  inline CloseConnectionResponse& operator=(
      const CloseConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseConnectionResponse& default_instance();

  void Swap(CloseConnectionResponse* other);

  // implements Message ----------------------------------------------

  CloseConnectionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseConnectionResponse& from);
  void MergeFrom(const CloseConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::proto::ResponseCode& rc() const;
  inline ::proto::ResponseCode* mutable_rc();
  inline ::proto::ResponseCode* release_rc();
  inline void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.CloseConnectionResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ResponseCode* rc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static CloseConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class DataRequest : public ::google::protobuf::Message {
 public:
  DataRequest();
  virtual ~DataRequest();

  DataRequest(const DataRequest& from);

  inline DataRequest& operator=(const DataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRequest& default_instance();

  void Swap(DataRequest* other);

  // implements Message ----------------------------------------------

  DataRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataRequest& from);
  void MergeFrom(const DataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 conn_key = 1;
  inline bool has_conn_key() const;
  inline void clear_conn_key();
  static const int kConnKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 conn_key() const;
  inline void set_conn_key(::google::protobuf::uint64 value);

  // repeated bytes data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const void* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data()
      const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:proto.DataRequest)
 private:
  inline void set_has_conn_key();
  inline void clear_has_conn_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 conn_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static DataRequest* default_instance_;
};
// -------------------------------------------------------------------

class DataResponse : public ::google::protobuf::Message {
 public:
  DataResponse();
  virtual ~DataResponse();

  DataResponse(const DataResponse& from);

  inline DataResponse& operator=(const DataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataResponse& default_instance();

  void Swap(DataResponse* other);

  // implements Message ----------------------------------------------

  DataResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataResponse& from);
  void MergeFrom(const DataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::proto::ResponseCode& rc() const;
  inline ::proto::ResponseCode* mutable_rc();
  inline ::proto::ResponseCode* release_rc();
  inline void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.DataResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::ResponseCode* rc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static DataResponse* default_instance_;
};
// ===================================================================

// ===================================================================

// Message

// required .proto.Head head = 1;
inline bool Message::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_head() { _has_bits_[0] |= 0x00000001u; }
inline void Message::clear_has_head() { _has_bits_[0] &= ~0x00000001u; }
inline void Message::clear_head() {
  if (head_ != NULL) head_->::proto::Head::Clear();
  clear_has_head();
}
inline const ::proto::Head& Message::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::proto::Head* Message::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::proto::Head;
  return head_;
}
inline ::proto::Head* Message::release_head() {
  clear_has_head();
  ::proto::Head* temp = head_;
  head_ = NULL;
  return temp;
}
inline void Message::set_allocated_head(::proto::Head* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .proto.Body body = 2;
inline bool Message::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_body() { _has_bits_[0] |= 0x00000002u; }
inline void Message::clear_has_body() { _has_bits_[0] &= ~0x00000002u; }
inline void Message::clear_body() {
  if (body_ != NULL) body_->::proto::Body::Clear();
  clear_has_body();
}
inline const ::proto::Body& Message::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::proto::Body* Message::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::proto::Body;
  return body_;
}
inline ::proto::Body* Message::release_body() {
  clear_has_body();
  ::proto::Body* temp = body_;
  body_ = NULL;
  return temp;
}
inline void Message::set_allocated_body(::proto::Body* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}

// -------------------------------------------------------------------

// Head

// required uint32 version = 1;
inline bool Head::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_version() { _has_bits_[0] |= 0x00000001u; }
inline void Head::clear_has_version() { _has_bits_[0] &= ~0x00000001u; }
inline void Head::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Head::version() const { return version_; }
inline void Head::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required uint32 random_num = 2;
inline bool Head::has_random_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_random_num() { _has_bits_[0] |= 0x00000002u; }
inline void Head::clear_has_random_num() { _has_bits_[0] &= ~0x00000002u; }
inline void Head::clear_random_num() {
  random_num_ = 0u;
  clear_has_random_num();
}
inline ::google::protobuf::uint32 Head::random_num() const {
  return random_num_;
}
inline void Head::set_random_num(::google::protobuf::uint32 value) {
  set_has_random_num();
  random_num_ = value;
}

// required uint32 flow_no = 3;
inline bool Head::has_flow_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_flow_no() { _has_bits_[0] |= 0x00000004u; }
inline void Head::clear_has_flow_no() { _has_bits_[0] &= ~0x00000004u; }
inline void Head::clear_flow_no() {
  flow_no_ = 0u;
  clear_has_flow_no();
}
inline ::google::protobuf::uint32 Head::flow_no() const { return flow_no_; }
inline void Head::set_flow_no(::google::protobuf::uint32 value) {
  set_has_flow_no();
  flow_no_ = value;
}

// required int32 message_type = 4;
inline bool Head::has_message_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Head::set_has_message_type() { _has_bits_[0] |= 0x00000008u; }
inline void Head::clear_has_message_type() { _has_bits_[0] &= ~0x00000008u; }
inline void Head::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 Head::message_type() const {
  return message_type_;
}
inline void Head::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
}

// required uint32 source_entity = 5;
inline bool Head::has_source_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Head::set_has_source_entity() { _has_bits_[0] |= 0x00000010u; }
inline void Head::clear_has_source_entity() { _has_bits_[0] &= ~0x00000010u; }
inline void Head::clear_source_entity() {
  source_entity_ = 0u;
  clear_has_source_entity();
}
inline ::google::protobuf::uint32 Head::source_entity() const {
  return source_entity_;
}
inline void Head::set_source_entity(::google::protobuf::uint32 value) {
  set_has_source_entity();
  source_entity_ = value;
}

// optional uint32 dest_entity = 6;
inline bool Head::has_dest_entity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Head::set_has_dest_entity() { _has_bits_[0] |= 0x00000020u; }
inline void Head::clear_has_dest_entity() { _has_bits_[0] &= ~0x00000020u; }
inline void Head::clear_dest_entity() {
  dest_entity_ = 0u;
  clear_has_dest_entity();
}
inline ::google::protobuf::uint32 Head::dest_entity() const {
  return dest_entity_;
}
inline void Head::set_dest_entity(::google::protobuf::uint32 value) {
  set_has_dest_entity();
  dest_entity_ = value;
}

// optional string call_purpose = 7;
inline bool Head::has_call_purpose() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Head::set_has_call_purpose() { _has_bits_[0] |= 0x00000040u; }
inline void Head::clear_has_call_purpose() { _has_bits_[0] &= ~0x00000040u; }
inline void Head::clear_call_purpose() {
  if (call_purpose_ != &::google::protobuf::internal::kEmptyString) {
    call_purpose_->clear();
  }
  clear_has_call_purpose();
}
inline const ::std::string& Head::call_purpose() const {
  return *call_purpose_;
}
inline void Head::set_call_purpose(const ::std::string& value) {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  call_purpose_->assign(value);
}
inline void Head::set_call_purpose(const char* value) {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  call_purpose_->assign(value);
}
inline void Head::set_call_purpose(const char* value, size_t size) {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  call_purpose_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_call_purpose() {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  return call_purpose_;
}
inline ::std::string* Head::release_call_purpose() {
  clear_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = call_purpose_;
    call_purpose_ = const_cast< ::std::string*>(
        &::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_call_purpose(::std::string* call_purpose) {
  if (call_purpose_ != &::google::protobuf::internal::kEmptyString) {
    delete call_purpose_;
  }
  if (call_purpose) {
    set_has_call_purpose();
    call_purpose_ = call_purpose;
  } else {
    clear_has_call_purpose();
    call_purpose_ = const_cast< ::std::string*>(
        &::google::protobuf::internal::kEmptyString);
  }
}

// optional string auth_key = 8;
inline bool Head::has_auth_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Head::set_has_auth_key() { _has_bits_[0] |= 0x00000080u; }
inline void Head::clear_has_auth_key() { _has_bits_[0] &= ~0x00000080u; }
inline void Head::clear_auth_key() {
  if (auth_key_ != &::google::protobuf::internal::kEmptyString) {
    auth_key_->clear();
  }
  clear_has_auth_key();
}
inline const ::std::string& Head::auth_key() const { return *auth_key_; }
inline void Head::set_auth_key(const ::std::string& value) {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  auth_key_->assign(value);
}
inline void Head::set_auth_key(const char* value) {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  auth_key_->assign(value);
}
inline void Head::set_auth_key(const char* value, size_t size) {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  auth_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_auth_key() {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  return auth_key_;
}
inline ::std::string* Head::release_auth_key() {
  clear_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_key_;
    auth_key_ = const_cast< ::std::string*>(
        &::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Head::set_allocated_auth_key(::std::string* auth_key) {
  if (auth_key_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_key_;
  }
  if (auth_key) {
    set_has_auth_key();
    auth_key_ = auth_key;
  } else {
    clear_has_auth_key();
    auth_key_ = const_cast< ::std::string*>(
        &::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 session_key = 9;
inline bool Head::has_session_key() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Head::set_has_session_key() { _has_bits_[0] |= 0x00000100u; }
inline void Head::clear_has_session_key() { _has_bits_[0] &= ~0x00000100u; }
inline void Head::clear_session_key() {
  session_key_ = GOOGLE_ULONGLONG(0);
  clear_has_session_key();
}
inline ::google::protobuf::uint64 Head::session_key() const {
  return session_key_;
}
inline void Head::set_session_key(::google::protobuf::uint64 value) {
  set_has_session_key();
  session_key_ = value;
}

// -------------------------------------------------------------------

// Body

// optional .proto.ListenRequest listen_request = 1;
inline bool Body::has_listen_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Body::set_has_listen_request() { _has_bits_[0] |= 0x00000001u; }
inline void Body::clear_has_listen_request() { _has_bits_[0] &= ~0x00000001u; }
inline void Body::clear_listen_request() {
  if (listen_request_ != NULL) listen_request_->::proto::ListenRequest::Clear();
  clear_has_listen_request();
}
inline const ::proto::ListenRequest& Body::listen_request() const {
  return listen_request_ != NULL ? *listen_request_
                                 : *default_instance_->listen_request_;
}
inline ::proto::ListenRequest* Body::mutable_listen_request() {
  set_has_listen_request();
  if (listen_request_ == NULL) listen_request_ = new ::proto::ListenRequest;
  return listen_request_;
}
inline ::proto::ListenRequest* Body::release_listen_request() {
  clear_has_listen_request();
  ::proto::ListenRequest* temp = listen_request_;
  listen_request_ = NULL;
  return temp;
}
inline void Body::set_allocated_listen_request(
    ::proto::ListenRequest* listen_request) {
  delete listen_request_;
  listen_request_ = listen_request;
  if (listen_request) {
    set_has_listen_request();
  } else {
    clear_has_listen_request();
  }
}

// optional .proto.ListenResponse listen_response = 2;
inline bool Body::has_listen_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Body::set_has_listen_response() { _has_bits_[0] |= 0x00000002u; }
inline void Body::clear_has_listen_response() { _has_bits_[0] &= ~0x00000002u; }
inline void Body::clear_listen_response() {
  if (listen_response_ != NULL)
    listen_response_->::proto::ListenResponse::Clear();
  clear_has_listen_response();
}
inline const ::proto::ListenResponse& Body::listen_response() const {
  return listen_response_ != NULL ? *listen_response_
                                  : *default_instance_->listen_response_;
}
inline ::proto::ListenResponse* Body::mutable_listen_response() {
  set_has_listen_response();
  if (listen_response_ == NULL) listen_response_ = new ::proto::ListenResponse;
  return listen_response_;
}
inline ::proto::ListenResponse* Body::release_listen_response() {
  clear_has_listen_response();
  ::proto::ListenResponse* temp = listen_response_;
  listen_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_listen_response(
    ::proto::ListenResponse* listen_response) {
  delete listen_response_;
  listen_response_ = listen_response;
  if (listen_response) {
    set_has_listen_response();
  } else {
    clear_has_listen_response();
  }
}

// optional .proto.Ping ping = 3;
inline bool Body::has_ping() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Body::set_has_ping() { _has_bits_[0] |= 0x00000004u; }
inline void Body::clear_has_ping() { _has_bits_[0] &= ~0x00000004u; }
inline void Body::clear_ping() {
  if (ping_ != NULL) ping_->::proto::Ping::Clear();
  clear_has_ping();
}
inline const ::proto::Ping& Body::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::proto::Ping* Body::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::proto::Ping;
  return ping_;
}
inline ::proto::Ping* Body::release_ping() {
  clear_has_ping();
  ::proto::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void Body::set_allocated_ping(::proto::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
}

// optional .proto.Pong pong = 4;
inline bool Body::has_pong() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Body::set_has_pong() { _has_bits_[0] |= 0x00000008u; }
inline void Body::clear_has_pong() { _has_bits_[0] &= ~0x00000008u; }
inline void Body::clear_pong() {
  if (pong_ != NULL) pong_->::proto::Pong::Clear();
  clear_has_pong();
}
inline const ::proto::Pong& Body::pong() const {
  return pong_ != NULL ? *pong_ : *default_instance_->pong_;
}
inline ::proto::Pong* Body::mutable_pong() {
  set_has_pong();
  if (pong_ == NULL) pong_ = new ::proto::Pong;
  return pong_;
}
inline ::proto::Pong* Body::release_pong() {
  clear_has_pong();
  ::proto::Pong* temp = pong_;
  pong_ = NULL;
  return temp;
}
inline void Body::set_allocated_pong(::proto::Pong* pong) {
  delete pong_;
  pong_ = pong;
  if (pong) {
    set_has_pong();
  } else {
    clear_has_pong();
  }
}

// optional .proto.LogoutRequest logout_request = 5;
inline bool Body::has_logout_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Body::set_has_logout_request() { _has_bits_[0] |= 0x00000010u; }
inline void Body::clear_has_logout_request() { _has_bits_[0] &= ~0x00000010u; }
inline void Body::clear_logout_request() {
  if (logout_request_ != NULL) logout_request_->::proto::LogoutRequest::Clear();
  clear_has_logout_request();
}
inline const ::proto::LogoutRequest& Body::logout_request() const {
  return logout_request_ != NULL ? *logout_request_
                                 : *default_instance_->logout_request_;
}
inline ::proto::LogoutRequest* Body::mutable_logout_request() {
  set_has_logout_request();
  if (logout_request_ == NULL) logout_request_ = new ::proto::LogoutRequest;
  return logout_request_;
}
inline ::proto::LogoutRequest* Body::release_logout_request() {
  clear_has_logout_request();
  ::proto::LogoutRequest* temp = logout_request_;
  logout_request_ = NULL;
  return temp;
}
inline void Body::set_allocated_logout_request(
    ::proto::LogoutRequest* logout_request) {
  delete logout_request_;
  logout_request_ = logout_request;
  if (logout_request) {
    set_has_logout_request();
  } else {
    clear_has_logout_request();
  }
}

// optional .proto.LogoutResponse logout_response = 6;
inline bool Body::has_logout_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Body::set_has_logout_response() { _has_bits_[0] |= 0x00000020u; }
inline void Body::clear_has_logout_response() { _has_bits_[0] &= ~0x00000020u; }
inline void Body::clear_logout_response() {
  if (logout_response_ != NULL)
    logout_response_->::proto::LogoutResponse::Clear();
  clear_has_logout_response();
}
inline const ::proto::LogoutResponse& Body::logout_response() const {
  return logout_response_ != NULL ? *logout_response_
                                  : *default_instance_->logout_response_;
}
inline ::proto::LogoutResponse* Body::mutable_logout_response() {
  set_has_logout_response();
  if (logout_response_ == NULL) logout_response_ = new ::proto::LogoutResponse;
  return logout_response_;
}
inline ::proto::LogoutResponse* Body::release_logout_response() {
  clear_has_logout_response();
  ::proto::LogoutResponse* temp = logout_response_;
  logout_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_logout_response(
    ::proto::LogoutResponse* logout_response) {
  delete logout_response_;
  logout_response_ = logout_response;
  if (logout_response) {
    set_has_logout_response();
  } else {
    clear_has_logout_response();
  }
}

// optional .proto.NewConnectionRequest new_connection_request = 7;
inline bool Body::has_new_connection_request() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Body::set_has_new_connection_request() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Body::clear_has_new_connection_request() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Body::clear_new_connection_request() {
  if (new_connection_request_ != NULL)
    new_connection_request_->::proto::NewConnectionRequest::Clear();
  clear_has_new_connection_request();
}
inline const ::proto::NewConnectionRequest& Body::new_connection_request()
    const {
  return new_connection_request_ != NULL
             ? *new_connection_request_
             : *default_instance_->new_connection_request_;
}
inline ::proto::NewConnectionRequest* Body::mutable_new_connection_request() {
  set_has_new_connection_request();
  if (new_connection_request_ == NULL)
    new_connection_request_ = new ::proto::NewConnectionRequest;
  return new_connection_request_;
}
inline ::proto::NewConnectionRequest* Body::release_new_connection_request() {
  clear_has_new_connection_request();
  ::proto::NewConnectionRequest* temp = new_connection_request_;
  new_connection_request_ = NULL;
  return temp;
}
inline void Body::set_allocated_new_connection_request(
    ::proto::NewConnectionRequest* new_connection_request) {
  delete new_connection_request_;
  new_connection_request_ = new_connection_request;
  if (new_connection_request) {
    set_has_new_connection_request();
  } else {
    clear_has_new_connection_request();
  }
}

// optional .proto.NewConnectionResponse new_connection_response = 8;
inline bool Body::has_new_connection_response() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Body::set_has_new_connection_response() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Body::clear_has_new_connection_response() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Body::clear_new_connection_response() {
  if (new_connection_response_ != NULL)
    new_connection_response_->::proto::NewConnectionResponse::Clear();
  clear_has_new_connection_response();
}
inline const ::proto::NewConnectionResponse& Body::new_connection_response()
    const {
  return new_connection_response_ != NULL
             ? *new_connection_response_
             : *default_instance_->new_connection_response_;
}
inline ::proto::NewConnectionResponse* Body::mutable_new_connection_response() {
  set_has_new_connection_response();
  if (new_connection_response_ == NULL)
    new_connection_response_ = new ::proto::NewConnectionResponse;
  return new_connection_response_;
}
inline ::proto::NewConnectionResponse* Body::release_new_connection_response() {
  clear_has_new_connection_response();
  ::proto::NewConnectionResponse* temp = new_connection_response_;
  new_connection_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_new_connection_response(
    ::proto::NewConnectionResponse* new_connection_response) {
  delete new_connection_response_;
  new_connection_response_ = new_connection_response;
  if (new_connection_response) {
    set_has_new_connection_response();
  } else {
    clear_has_new_connection_response();
  }
}

// optional .proto.CloseConnectionRequest close_connection_request = 9;
inline bool Body::has_close_connection_request() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Body::set_has_close_connection_request() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Body::clear_has_close_connection_request() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Body::clear_close_connection_request() {
  if (close_connection_request_ != NULL)
    close_connection_request_->::proto::CloseConnectionRequest::Clear();
  clear_has_close_connection_request();
}
inline const ::proto::CloseConnectionRequest& Body::close_connection_request()
    const {
  return close_connection_request_ != NULL
             ? *close_connection_request_
             : *default_instance_->close_connection_request_;
}
inline ::proto::CloseConnectionRequest*
Body::mutable_close_connection_request() {
  set_has_close_connection_request();
  if (close_connection_request_ == NULL)
    close_connection_request_ = new ::proto::CloseConnectionRequest;
  return close_connection_request_;
}
inline ::proto::CloseConnectionRequest*
Body::release_close_connection_request() {
  clear_has_close_connection_request();
  ::proto::CloseConnectionRequest* temp = close_connection_request_;
  close_connection_request_ = NULL;
  return temp;
}
inline void Body::set_allocated_close_connection_request(
    ::proto::CloseConnectionRequest* close_connection_request) {
  delete close_connection_request_;
  close_connection_request_ = close_connection_request;
  if (close_connection_request) {
    set_has_close_connection_request();
  } else {
    clear_has_close_connection_request();
  }
}

// optional .proto.CloseConnectionResponse close_connection_response = 10;
inline bool Body::has_close_connection_response() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Body::set_has_close_connection_response() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Body::clear_has_close_connection_response() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Body::clear_close_connection_response() {
  if (close_connection_response_ != NULL)
    close_connection_response_->::proto::CloseConnectionResponse::Clear();
  clear_has_close_connection_response();
}
inline const ::proto::CloseConnectionResponse& Body::close_connection_response()
    const {
  return close_connection_response_ != NULL
             ? *close_connection_response_
             : *default_instance_->close_connection_response_;
}
inline ::proto::CloseConnectionResponse*
Body::mutable_close_connection_response() {
  set_has_close_connection_response();
  if (close_connection_response_ == NULL)
    close_connection_response_ = new ::proto::CloseConnectionResponse;
  return close_connection_response_;
}
inline ::proto::CloseConnectionResponse*
Body::release_close_connection_response() {
  clear_has_close_connection_response();
  ::proto::CloseConnectionResponse* temp = close_connection_response_;
  close_connection_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_close_connection_response(
    ::proto::CloseConnectionResponse* close_connection_response) {
  delete close_connection_response_;
  close_connection_response_ = close_connection_response;
  if (close_connection_response) {
    set_has_close_connection_response();
  } else {
    clear_has_close_connection_response();
  }
}

// optional .proto.DataRequest data_request = 11;
inline bool Body::has_data_request() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Body::set_has_data_request() { _has_bits_[0] |= 0x00000400u; }
inline void Body::clear_has_data_request() { _has_bits_[0] &= ~0x00000400u; }
inline void Body::clear_data_request() {
  if (data_request_ != NULL) data_request_->::proto::DataRequest::Clear();
  clear_has_data_request();
}
inline const ::proto::DataRequest& Body::data_request() const {
  return data_request_ != NULL ? *data_request_
                               : *default_instance_->data_request_;
}
inline ::proto::DataRequest* Body::mutable_data_request() {
  set_has_data_request();
  if (data_request_ == NULL) data_request_ = new ::proto::DataRequest;
  return data_request_;
}
inline ::proto::DataRequest* Body::release_data_request() {
  clear_has_data_request();
  ::proto::DataRequest* temp = data_request_;
  data_request_ = NULL;
  return temp;
}
inline void Body::set_allocated_data_request(
    ::proto::DataRequest* data_request) {
  delete data_request_;
  data_request_ = data_request;
  if (data_request) {
    set_has_data_request();
  } else {
    clear_has_data_request();
  }
}

// optional .proto.DataResponse data_response = 12;
inline bool Body::has_data_response() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Body::set_has_data_response() { _has_bits_[0] |= 0x00000800u; }
inline void Body::clear_has_data_response() { _has_bits_[0] &= ~0x00000800u; }
inline void Body::clear_data_response() {
  if (data_response_ != NULL) data_response_->::proto::DataResponse::Clear();
  clear_has_data_response();
}
inline const ::proto::DataResponse& Body::data_response() const {
  return data_response_ != NULL ? *data_response_
                                : *default_instance_->data_response_;
}
inline ::proto::DataResponse* Body::mutable_data_response() {
  set_has_data_response();
  if (data_response_ == NULL) data_response_ = new ::proto::DataResponse;
  return data_response_;
}
inline ::proto::DataResponse* Body::release_data_response() {
  clear_has_data_response();
  ::proto::DataResponse* temp = data_response_;
  data_response_ = NULL;
  return temp;
}
inline void Body::set_allocated_data_response(
    ::proto::DataResponse* data_response) {
  delete data_response_;
  data_response_ = data_response;
  if (data_response) {
    set_has_data_response();
  } else {
    clear_has_data_response();
  }
}

// -------------------------------------------------------------------

// ResponseCode

// required int32 retcode = 1;
inline bool ResponseCode::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_retcode() { _has_bits_[0] |= 0x00000001u; }
inline void ResponseCode::clear_has_retcode() { _has_bits_[0] &= ~0x00000001u; }
inline void ResponseCode::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 ResponseCode::retcode() const {
  return retcode_;
}
inline void ResponseCode::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string error_message = 2;
inline bool ResponseCode::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCode::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCode::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCode::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& ResponseCode::error_message() const {
  return *error_message_;
}
inline void ResponseCode::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ResponseCode::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ResponseCode::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseCode::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* ResponseCode::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(
        &::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseCode::set_allocated_error_message(
    ::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(
        &::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ListenRequest

// optional uint32 self_ipv4 = 1;
inline bool ListenRequest::has_self_ipv4() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListenRequest::set_has_self_ipv4() { _has_bits_[0] |= 0x00000001u; }
inline void ListenRequest::clear_has_self_ipv4() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListenRequest::clear_self_ipv4() {
  self_ipv4_ = 0u;
  clear_has_self_ipv4();
}
inline ::google::protobuf::uint32 ListenRequest::self_ipv4() const {
  return self_ipv4_;
}
inline void ListenRequest::set_self_ipv4(::google::protobuf::uint32 value) {
  set_has_self_ipv4();
  self_ipv4_ = value;
}

// repeated bytes self_ipv6 = 2;
inline int ListenRequest::self_ipv6_size() const { return self_ipv6_.size(); }
inline void ListenRequest::clear_self_ipv6() { self_ipv6_.Clear(); }
inline const ::std::string& ListenRequest::self_ipv6(int index) const {
  return self_ipv6_.Get(index);
}
inline ::std::string* ListenRequest::mutable_self_ipv6(int index) {
  return self_ipv6_.Mutable(index);
}
inline void ListenRequest::set_self_ipv6(int index,
                                         const ::std::string& value) {
  self_ipv6_.Mutable(index)->assign(value);
}
inline void ListenRequest::set_self_ipv6(int index, const char* value) {
  self_ipv6_.Mutable(index)->assign(value);
}
inline void ListenRequest::set_self_ipv6(int index, const void* value,
                                         size_t size) {
  self_ipv6_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListenRequest::add_self_ipv6() {
  return self_ipv6_.Add();
}
inline void ListenRequest::add_self_ipv6(const ::std::string& value) {
  self_ipv6_.Add()->assign(value);
}
inline void ListenRequest::add_self_ipv6(const char* value) {
  self_ipv6_.Add()->assign(value);
}
inline void ListenRequest::add_self_ipv6(const void* value, size_t size) {
  self_ipv6_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListenRequest::self_ipv6() const {
  return self_ipv6_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListenRequest::mutable_self_ipv6() {
  return &self_ipv6_;
}

// required uint32 self_port = 3;
inline bool ListenRequest::has_self_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListenRequest::set_has_self_port() { _has_bits_[0] |= 0x00000004u; }
inline void ListenRequest::clear_has_self_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListenRequest::clear_self_port() {
  self_port_ = 0u;
  clear_has_self_port();
}
inline ::google::protobuf::uint32 ListenRequest::self_port() const {
  return self_port_;
}
inline void ListenRequest::set_self_port(::google::protobuf::uint32 value) {
  set_has_self_port();
  self_port_ = value;
}

// required uint32 listen_port = 4;
inline bool ListenRequest::has_listen_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListenRequest::set_has_listen_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListenRequest::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListenRequest::clear_listen_port() {
  listen_port_ = 0u;
  clear_has_listen_port();
}
inline ::google::protobuf::uint32 ListenRequest::listen_port() const {
  return listen_port_;
}
inline void ListenRequest::set_listen_port(::google::protobuf::uint32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// -------------------------------------------------------------------

// ListenResponse

// required .proto.ResponseCode rc = 1;
inline bool ListenResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListenResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void ListenResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void ListenResponse::clear_rc() {
  if (rc_ != NULL) rc_->::proto::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& ListenResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::proto::ResponseCode* ListenResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::proto::ResponseCode;
  return rc_;
}
inline ::proto::ResponseCode* ListenResponse::release_rc() {
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void ListenResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// optional uint64 session_key = 2;
inline bool ListenResponse::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListenResponse::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListenResponse::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListenResponse::clear_session_key() {
  session_key_ = GOOGLE_ULONGLONG(0);
  clear_has_session_key();
}
inline ::google::protobuf::uint64 ListenResponse::session_key() const {
  return session_key_;
}
inline void ListenResponse::set_session_key(::google::protobuf::uint64 value) {
  set_has_session_key();
  session_key_ = value;
}

// -------------------------------------------------------------------

// Ping

// required uint64 time = 1;
inline bool Ping::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_time() { _has_bits_[0] |= 0x00000001u; }
inline void Ping::clear_has_time() { _has_bits_[0] &= ~0x00000001u; }
inline void Ping::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Ping::time() const { return time_; }
inline void Ping::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Pong

// required .proto.ResponseCode rc = 1;
inline bool Pong::has_rc() const { return (_has_bits_[0] & 0x00000001u) != 0; }
inline void Pong::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void Pong::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void Pong::clear_rc() {
  if (rc_ != NULL) rc_->::proto::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& Pong::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::proto::ResponseCode* Pong::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::proto::ResponseCode;
  return rc_;
}
inline ::proto::ResponseCode* Pong::release_rc() {
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void Pong::set_allocated_rc(::proto::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// required uint64 time = 2;
inline bool Pong::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pong::set_has_time() { _has_bits_[0] |= 0x00000002u; }
inline void Pong::clear_has_time() { _has_bits_[0] &= ~0x00000002u; }
inline void Pong::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Pong::time() const { return time_; }
inline void Pong::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// LogoutRequest

// -------------------------------------------------------------------

// LogoutResponse

// required .proto.ResponseCode rc = 1;
inline bool LogoutResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void LogoutResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void LogoutResponse::clear_rc() {
  if (rc_ != NULL) rc_->::proto::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& LogoutResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::proto::ResponseCode* LogoutResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::proto::ResponseCode;
  return rc_;
}
inline ::proto::ResponseCode* LogoutResponse::release_rc() {
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void LogoutResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// -------------------------------------------------------------------

// NewConnectionRequest

// optional uint32 ip_v4 = 1;
inline bool NewConnectionRequest::has_ip_v4() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewConnectionRequest::set_has_ip_v4() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewConnectionRequest::clear_has_ip_v4() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewConnectionRequest::clear_ip_v4() {
  ip_v4_ = 0u;
  clear_has_ip_v4();
}
inline ::google::protobuf::uint32 NewConnectionRequest::ip_v4() const {
  return ip_v4_;
}
inline void NewConnectionRequest::set_ip_v4(::google::protobuf::uint32 value) {
  set_has_ip_v4();
  ip_v4_ = value;
}

// repeated bytes ip_v6 = 2;
inline int NewConnectionRequest::ip_v6_size() const { return ip_v6_.size(); }
inline void NewConnectionRequest::clear_ip_v6() { ip_v6_.Clear(); }
inline const ::std::string& NewConnectionRequest::ip_v6(int index) const {
  return ip_v6_.Get(index);
}
inline ::std::string* NewConnectionRequest::mutable_ip_v6(int index) {
  return ip_v6_.Mutable(index);
}
inline void NewConnectionRequest::set_ip_v6(int index,
                                            const ::std::string& value) {
  ip_v6_.Mutable(index)->assign(value);
}
inline void NewConnectionRequest::set_ip_v6(int index, const char* value) {
  ip_v6_.Mutable(index)->assign(value);
}
inline void NewConnectionRequest::set_ip_v6(int index, const void* value,
                                            size_t size) {
  ip_v6_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewConnectionRequest::add_ip_v6() { return ip_v6_.Add(); }
inline void NewConnectionRequest::add_ip_v6(const ::std::string& value) {
  ip_v6_.Add()->assign(value);
}
inline void NewConnectionRequest::add_ip_v6(const char* value) {
  ip_v6_.Add()->assign(value);
}
inline void NewConnectionRequest::add_ip_v6(const void* value, size_t size) {
  ip_v6_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NewConnectionRequest::ip_v6() const {
  return ip_v6_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NewConnectionRequest::mutable_ip_v6() {
  return &ip_v6_;
}

// required uint32 port = 3;
inline bool NewConnectionRequest::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewConnectionRequest::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewConnectionRequest::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewConnectionRequest::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 NewConnectionRequest::port() const {
  return port_;
}
inline void NewConnectionRequest::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required uint64 conn_key = 4;
inline bool NewConnectionRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewConnectionRequest::set_has_conn_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewConnectionRequest::clear_has_conn_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewConnectionRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 NewConnectionRequest::conn_key() const {
  return conn_key_;
}
inline void NewConnectionRequest::set_conn_key(
    ::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
}

// -------------------------------------------------------------------

// NewConnectionResponse

// required .proto.ResponseCode rc = 1;
inline bool NewConnectionResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewConnectionResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewConnectionResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewConnectionResponse::clear_rc() {
  if (rc_ != NULL) rc_->::proto::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& NewConnectionResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::proto::ResponseCode* NewConnectionResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::proto::ResponseCode;
  return rc_;
}
inline ::proto::ResponseCode* NewConnectionResponse::release_rc() {
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void NewConnectionResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// -------------------------------------------------------------------

// CloseConnectionRequest

// required uint64 conn_key = 1;
inline bool CloseConnectionRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseConnectionRequest::set_has_conn_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseConnectionRequest::clear_has_conn_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseConnectionRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 CloseConnectionRequest::conn_key() const {
  return conn_key_;
}
inline void CloseConnectionRequest::set_conn_key(
    ::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
}

// -------------------------------------------------------------------

// CloseConnectionResponse

// required .proto.ResponseCode rc = 1;
inline bool CloseConnectionResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseConnectionResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseConnectionResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseConnectionResponse::clear_rc() {
  if (rc_ != NULL) rc_->::proto::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& CloseConnectionResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::proto::ResponseCode* CloseConnectionResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::proto::ResponseCode;
  return rc_;
}
inline ::proto::ResponseCode* CloseConnectionResponse::release_rc() {
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void CloseConnectionResponse::set_allocated_rc(
    ::proto::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// -------------------------------------------------------------------

// DataRequest

// required uint64 conn_key = 1;
inline bool DataRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataRequest::set_has_conn_key() { _has_bits_[0] |= 0x00000001u; }
inline void DataRequest::clear_has_conn_key() { _has_bits_[0] &= ~0x00000001u; }
inline void DataRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 DataRequest::conn_key() const {
  return conn_key_;
}
inline void DataRequest::set_conn_key(::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
}

// repeated bytes data = 2;
inline int DataRequest::data_size() const { return data_.size(); }
inline void DataRequest::clear_data() { data_.Clear(); }
inline const ::std::string& DataRequest::data(int index) const {
  return data_.Get(index);
}
inline ::std::string* DataRequest::mutable_data(int index) {
  return data_.Mutable(index);
}
inline void DataRequest::set_data(int index, const ::std::string& value) {
  data_.Mutable(index)->assign(value);
}
inline void DataRequest::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
}
inline void DataRequest::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataRequest::add_data() { return data_.Add(); }
inline void DataRequest::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
}
inline void DataRequest::add_data(const char* value) {
  data_.Add()->assign(value);
}
inline void DataRequest::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataRequest::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataRequest::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// DataResponse

// required .proto.ResponseCode rc = 1;
inline bool DataResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void DataResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void DataResponse::clear_rc() {
  if (rc_ != NULL) rc_->::proto::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& DataResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::proto::ResponseCode* DataResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::proto::ResponseCode;
  return rc_;
}
inline ::proto::ResponseCode* DataResponse::release_rc() {
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline void DataResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  delete rc_;
  rc_ = rc;
  if (rc) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::MessageType>() {
  return ::proto::MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
