// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <google/protobuf/stubs/common.h>

#include <string>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_2eproto

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable
      serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_2eproto
namespace proto {
class Body;
class BodyDefaultTypeInternal;
extern BodyDefaultTypeInternal _Body_default_instance_;
class CloseConnectionRequest;
class CloseConnectionRequestDefaultTypeInternal;
extern CloseConnectionRequestDefaultTypeInternal
    _CloseConnectionRequest_default_instance_;
class CloseConnectionResponse;
class CloseConnectionResponseDefaultTypeInternal;
extern CloseConnectionResponseDefaultTypeInternal
    _CloseConnectionResponse_default_instance_;
class DataRequest;
class DataRequestDefaultTypeInternal;
extern DataRequestDefaultTypeInternal _DataRequest_default_instance_;
class DataResponse;
class DataResponseDefaultTypeInternal;
extern DataResponseDefaultTypeInternal _DataResponse_default_instance_;
class Head;
class HeadDefaultTypeInternal;
extern HeadDefaultTypeInternal _Head_default_instance_;
class ListenRequest;
class ListenRequestDefaultTypeInternal;
extern ListenRequestDefaultTypeInternal _ListenRequest_default_instance_;
class ListenResponse;
class ListenResponseDefaultTypeInternal;
extern ListenResponseDefaultTypeInternal _ListenResponse_default_instance_;
class LogoutRequest;
class LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class LogoutResponse;
class LogoutResponseDefaultTypeInternal;
extern LogoutResponseDefaultTypeInternal _LogoutResponse_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class NewConnectionRequest;
class NewConnectionRequestDefaultTypeInternal;
extern NewConnectionRequestDefaultTypeInternal
    _NewConnectionRequest_default_instance_;
class NewConnectionResponse;
class NewConnectionResponseDefaultTypeInternal;
extern NewConnectionResponseDefaultTypeInternal
    _NewConnectionResponse_default_instance_;
class PauseSendRequest;
class PauseSendRequestDefaultTypeInternal;
extern PauseSendRequestDefaultTypeInternal _PauseSendRequest_default_instance_;
class PauseSendResponse;
class PauseSendResponseDefaultTypeInternal;
extern PauseSendResponseDefaultTypeInternal
    _PauseSendResponse_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
class PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class ResponseCode;
class ResponseCodeDefaultTypeInternal;
extern ResponseCodeDefaultTypeInternal _ResponseCode_default_instance_;
class ResumeSendRequest;
class ResumeSendRequestDefaultTypeInternal;
extern ResumeSendRequestDefaultTypeInternal
    _ResumeSendRequest_default_instance_;
class ResumeSendResponse;
class ResumeSendResponseDefaultTypeInternal;
extern ResumeSendResponseDefaultTypeInternal
    _ResumeSendResponse_default_instance_;
}  // namespace proto
namespace google {
namespace protobuf {
template <>
::proto::Body* Arena::CreateMaybeMessage<::proto::Body>(Arena*);
template <>
::proto::CloseConnectionRequest*
Arena::CreateMaybeMessage<::proto::CloseConnectionRequest>(Arena*);
template <>
::proto::CloseConnectionResponse*
Arena::CreateMaybeMessage<::proto::CloseConnectionResponse>(Arena*);
template <>
::proto::DataRequest* Arena::CreateMaybeMessage<::proto::DataRequest>(Arena*);
template <>
::proto::DataResponse* Arena::CreateMaybeMessage<::proto::DataResponse>(Arena*);
template <>
::proto::Head* Arena::CreateMaybeMessage<::proto::Head>(Arena*);
template <>
::proto::ListenRequest* Arena::CreateMaybeMessage<::proto::ListenRequest>(
    Arena*);
template <>
::proto::ListenResponse* Arena::CreateMaybeMessage<::proto::ListenResponse>(
    Arena*);
template <>
::proto::LogoutRequest* Arena::CreateMaybeMessage<::proto::LogoutRequest>(
    Arena*);
template <>
::proto::LogoutResponse* Arena::CreateMaybeMessage<::proto::LogoutResponse>(
    Arena*);
template <>
::proto::Message* Arena::CreateMaybeMessage<::proto::Message>(Arena*);
template <>
::proto::NewConnectionRequest*
Arena::CreateMaybeMessage<::proto::NewConnectionRequest>(Arena*);
template <>
::proto::NewConnectionResponse*
Arena::CreateMaybeMessage<::proto::NewConnectionResponse>(Arena*);
template <>
::proto::PauseSendRequest* Arena::CreateMaybeMessage<::proto::PauseSendRequest>(
    Arena*);
template <>
::proto::PauseSendResponse*
Arena::CreateMaybeMessage<::proto::PauseSendResponse>(Arena*);
template <>
::proto::Ping* Arena::CreateMaybeMessage<::proto::Ping>(Arena*);
template <>
::proto::Pong* Arena::CreateMaybeMessage<::proto::Pong>(Arena*);
template <>
::proto::ResponseCode* Arena::CreateMaybeMessage<::proto::ResponseCode>(Arena*);
template <>
::proto::ResumeSendRequest*
Arena::CreateMaybeMessage<::proto::ResumeSendRequest>(Arena*);
template <>
::proto::ResumeSendResponse*
Arena::CreateMaybeMessage<::proto::ResumeSendResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {

enum MessageType {
  LISTEN_REQUEST = 1,
  LISTEN_RESPONSE = 2,
  PING = 3,
  PONG = 4,
  LOGOUT_REQUEST = 5,
  LOGOUT_RESPONSE = 6,
  NEW_CONNECTION_REQUEST = 7,
  NEW_CONNECTION_RESPONSE = 8,
  CLOSE_CONNECTION_REQUEST = 9,
  CLOSE_CONNECTION_RESONSE = 10,
  DATA_REQUEST = 11,
  DATA_RESPONSE = 12,
  PAUSE_SEND_REQUEST = 13,
  PAUSE_SEND_RESPONSE = 14,
  RESUME_SEND_REQUEST = 15,
  RESUME_SEND_RESPONSE = 16
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = LISTEN_REQUEST;
const MessageType MessageType_MAX = RESUME_SEND_RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(MessageType_descriptor(),
                                                  value);
}
inline bool MessageType_Parse(const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.Message)
                                                    */
{
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Message(Message&& from) noexcept : Message() { *this = ::std::move(from); }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(&_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.Head head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;

 private:
  const ::proto::Head& _internal_head() const;

 public:
  const ::proto::Head& head() const;
  ::proto::Head* release_head();
  ::proto::Head* mutable_head();
  void set_allocated_head(::proto::Head* head);

  // required .proto.Body body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;

 private:
  const ::proto::Body& _internal_body() const;

 public:
  const ::proto::Body& body() const;
  ::proto::Body* release_body();
  ::proto::Body* mutable_body();
  void set_allocated_body(::proto::Body* body);

  // @@protoc_insertion_point(class_scope:proto.Message)
 private:
  void set_has_head();
  void clear_has_head();
  void set_has_body();
  void clear_has_body();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::Head* head_;
  ::proto::Body* body_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Head
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:proto.Head) */ {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Head(Head&& from) noexcept : Head() { *this = ::std::move(from); }

  inline Head& operator=(Head&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Head* internal_default_instance() {
    return reinterpret_cast<const Head*>(&_Head_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;

  void Swap(Head* other);
  friend void swap(Head& a, Head& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Head* New() const final { return CreateMaybeMessage<Head>(NULL); }

  Head* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Head>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Head* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string call_purpose = 7;
  bool has_call_purpose() const;
  void clear_call_purpose();
  static const int kCallPurposeFieldNumber = 7;
  const ::std::string& call_purpose() const;
  void set_call_purpose(const ::std::string& value);
#if LANG_CXX11
  void set_call_purpose(::std::string&& value);
#endif
  void set_call_purpose(const char* value);
  void set_call_purpose(const char* value, size_t size);
  ::std::string* mutable_call_purpose();
  ::std::string* release_call_purpose();
  void set_allocated_call_purpose(::std::string* call_purpose);

  // optional string auth_key = 8;
  bool has_auth_key() const;
  void clear_auth_key();
  static const int kAuthKeyFieldNumber = 8;
  const ::std::string& auth_key() const;
  void set_auth_key(const ::std::string& value);
#if LANG_CXX11
  void set_auth_key(::std::string&& value);
#endif
  void set_auth_key(const char* value);
  void set_auth_key(const char* value, size_t size);
  ::std::string* mutable_auth_key();
  ::std::string* release_auth_key();
  void set_allocated_auth_key(::std::string* auth_key);

  // required uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // required uint32 random_num = 2;
  bool has_random_num() const;
  void clear_random_num();
  static const int kRandomNumFieldNumber = 2;
  ::google::protobuf::uint32 random_num() const;
  void set_random_num(::google::protobuf::uint32 value);

  // required uint32 flow_no = 3;
  bool has_flow_no() const;
  void clear_flow_no();
  static const int kFlowNoFieldNumber = 3;
  ::google::protobuf::uint32 flow_no() const;
  void set_flow_no(::google::protobuf::uint32 value);

  // required int32 message_type = 4;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 4;
  ::google::protobuf::int32 message_type() const;
  void set_message_type(::google::protobuf::int32 value);

  // required uint32 source_entity = 5;
  bool has_source_entity() const;
  void clear_source_entity();
  static const int kSourceEntityFieldNumber = 5;
  ::google::protobuf::uint32 source_entity() const;
  void set_source_entity(::google::protobuf::uint32 value);

  // optional uint32 dest_entity = 6;
  bool has_dest_entity() const;
  void clear_dest_entity();
  static const int kDestEntityFieldNumber = 6;
  ::google::protobuf::uint32 dest_entity() const;
  void set_dest_entity(::google::protobuf::uint32 value);

  // optional uint64 session_key = 9;
  bool has_session_key() const;
  void clear_session_key();
  static const int kSessionKeyFieldNumber = 9;
  ::google::protobuf::uint64 session_key() const;
  void set_session_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Head)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_random_num();
  void clear_has_random_num();
  void set_has_flow_no();
  void clear_has_flow_no();
  void set_has_message_type();
  void clear_has_message_type();
  void set_has_source_entity();
  void clear_has_source_entity();
  void set_has_dest_entity();
  void clear_has_dest_entity();
  void set_has_call_purpose();
  void clear_has_call_purpose();
  void set_has_auth_key();
  void clear_has_auth_key();
  void set_has_session_key();
  void clear_has_session_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr call_purpose_;
  ::google::protobuf::internal::ArenaStringPtr auth_key_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 random_num_;
  ::google::protobuf::uint32 flow_no_;
  ::google::protobuf::int32 message_type_;
  ::google::protobuf::uint32 source_entity_;
  ::google::protobuf::uint32 dest_entity_;
  ::google::protobuf::uint64 session_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Body
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:proto.Body) */ {
 public:
  Body();
  virtual ~Body();

  Body(const Body& from);

  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Body(Body&& from) noexcept : Body() { *this = ::std::move(from); }

  inline Body& operator=(Body&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Body& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Body* internal_default_instance() {
    return reinterpret_cast<const Body*>(&_Body_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;

  void Swap(Body* other);
  friend void swap(Body& a, Body& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Body* New() const final { return CreateMaybeMessage<Body>(NULL); }

  Body* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Body>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Body& from);
  void MergeFrom(const Body& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ListenRequest listen_request = 1;
  bool has_listen_request() const;
  void clear_listen_request();
  static const int kListenRequestFieldNumber = 1;

 private:
  const ::proto::ListenRequest& _internal_listen_request() const;

 public:
  const ::proto::ListenRequest& listen_request() const;
  ::proto::ListenRequest* release_listen_request();
  ::proto::ListenRequest* mutable_listen_request();
  void set_allocated_listen_request(::proto::ListenRequest* listen_request);

  // optional .proto.ListenResponse listen_response = 2;
  bool has_listen_response() const;
  void clear_listen_response();
  static const int kListenResponseFieldNumber = 2;

 private:
  const ::proto::ListenResponse& _internal_listen_response() const;

 public:
  const ::proto::ListenResponse& listen_response() const;
  ::proto::ListenResponse* release_listen_response();
  ::proto::ListenResponse* mutable_listen_response();
  void set_allocated_listen_response(::proto::ListenResponse* listen_response);

  // optional .proto.Ping ping = 3;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 3;

 private:
  const ::proto::Ping& _internal_ping() const;

 public:
  const ::proto::Ping& ping() const;
  ::proto::Ping* release_ping();
  ::proto::Ping* mutable_ping();
  void set_allocated_ping(::proto::Ping* ping);

  // optional .proto.Pong pong = 4;
  bool has_pong() const;
  void clear_pong();
  static const int kPongFieldNumber = 4;

 private:
  const ::proto::Pong& _internal_pong() const;

 public:
  const ::proto::Pong& pong() const;
  ::proto::Pong* release_pong();
  ::proto::Pong* mutable_pong();
  void set_allocated_pong(::proto::Pong* pong);

  // optional .proto.LogoutRequest logout_request = 5;
  bool has_logout_request() const;
  void clear_logout_request();
  static const int kLogoutRequestFieldNumber = 5;

 private:
  const ::proto::LogoutRequest& _internal_logout_request() const;

 public:
  const ::proto::LogoutRequest& logout_request() const;
  ::proto::LogoutRequest* release_logout_request();
  ::proto::LogoutRequest* mutable_logout_request();
  void set_allocated_logout_request(::proto::LogoutRequest* logout_request);

  // optional .proto.LogoutResponse logout_response = 6;
  bool has_logout_response() const;
  void clear_logout_response();
  static const int kLogoutResponseFieldNumber = 6;

 private:
  const ::proto::LogoutResponse& _internal_logout_response() const;

 public:
  const ::proto::LogoutResponse& logout_response() const;
  ::proto::LogoutResponse* release_logout_response();
  ::proto::LogoutResponse* mutable_logout_response();
  void set_allocated_logout_response(::proto::LogoutResponse* logout_response);

  // optional .proto.NewConnectionRequest new_connection_request = 7;
  bool has_new_connection_request() const;
  void clear_new_connection_request();
  static const int kNewConnectionRequestFieldNumber = 7;

 private:
  const ::proto::NewConnectionRequest& _internal_new_connection_request() const;

 public:
  const ::proto::NewConnectionRequest& new_connection_request() const;
  ::proto::NewConnectionRequest* release_new_connection_request();
  ::proto::NewConnectionRequest* mutable_new_connection_request();
  void set_allocated_new_connection_request(
      ::proto::NewConnectionRequest* new_connection_request);

  // optional .proto.NewConnectionResponse new_connection_response = 8;
  bool has_new_connection_response() const;
  void clear_new_connection_response();
  static const int kNewConnectionResponseFieldNumber = 8;

 private:
  const ::proto::NewConnectionResponse& _internal_new_connection_response()
      const;

 public:
  const ::proto::NewConnectionResponse& new_connection_response() const;
  ::proto::NewConnectionResponse* release_new_connection_response();
  ::proto::NewConnectionResponse* mutable_new_connection_response();
  void set_allocated_new_connection_response(
      ::proto::NewConnectionResponse* new_connection_response);

  // optional .proto.CloseConnectionRequest close_connection_request = 9;
  bool has_close_connection_request() const;
  void clear_close_connection_request();
  static const int kCloseConnectionRequestFieldNumber = 9;

 private:
  const ::proto::CloseConnectionRequest& _internal_close_connection_request()
      const;

 public:
  const ::proto::CloseConnectionRequest& close_connection_request() const;
  ::proto::CloseConnectionRequest* release_close_connection_request();
  ::proto::CloseConnectionRequest* mutable_close_connection_request();
  void set_allocated_close_connection_request(
      ::proto::CloseConnectionRequest* close_connection_request);

  // optional .proto.CloseConnectionResponse close_connection_response = 10;
  bool has_close_connection_response() const;
  void clear_close_connection_response();
  static const int kCloseConnectionResponseFieldNumber = 10;

 private:
  const ::proto::CloseConnectionResponse& _internal_close_connection_response()
      const;

 public:
  const ::proto::CloseConnectionResponse& close_connection_response() const;
  ::proto::CloseConnectionResponse* release_close_connection_response();
  ::proto::CloseConnectionResponse* mutable_close_connection_response();
  void set_allocated_close_connection_response(
      ::proto::CloseConnectionResponse* close_connection_response);

  // optional .proto.DataRequest data_request = 11;
  bool has_data_request() const;
  void clear_data_request();
  static const int kDataRequestFieldNumber = 11;

 private:
  const ::proto::DataRequest& _internal_data_request() const;

 public:
  const ::proto::DataRequest& data_request() const;
  ::proto::DataRequest* release_data_request();
  ::proto::DataRequest* mutable_data_request();
  void set_allocated_data_request(::proto::DataRequest* data_request);

  // optional .proto.DataResponse data_response = 12;
  bool has_data_response() const;
  void clear_data_response();
  static const int kDataResponseFieldNumber = 12;

 private:
  const ::proto::DataResponse& _internal_data_response() const;

 public:
  const ::proto::DataResponse& data_response() const;
  ::proto::DataResponse* release_data_response();
  ::proto::DataResponse* mutable_data_response();
  void set_allocated_data_response(::proto::DataResponse* data_response);

  // optional .proto.PauseSendRequest pause_send_request = 13;
  bool has_pause_send_request() const;
  void clear_pause_send_request();
  static const int kPauseSendRequestFieldNumber = 13;

 private:
  const ::proto::PauseSendRequest& _internal_pause_send_request() const;

 public:
  const ::proto::PauseSendRequest& pause_send_request() const;
  ::proto::PauseSendRequest* release_pause_send_request();
  ::proto::PauseSendRequest* mutable_pause_send_request();
  void set_allocated_pause_send_request(
      ::proto::PauseSendRequest* pause_send_request);

  // optional .proto.PauseSendResponse pause_send_response = 14;
  bool has_pause_send_response() const;
  void clear_pause_send_response();
  static const int kPauseSendResponseFieldNumber = 14;

 private:
  const ::proto::PauseSendResponse& _internal_pause_send_response() const;

 public:
  const ::proto::PauseSendResponse& pause_send_response() const;
  ::proto::PauseSendResponse* release_pause_send_response();
  ::proto::PauseSendResponse* mutable_pause_send_response();
  void set_allocated_pause_send_response(
      ::proto::PauseSendResponse* pause_send_response);

  // optional .proto.ResumeSendRequest resume_send_request = 15;
  bool has_resume_send_request() const;
  void clear_resume_send_request();
  static const int kResumeSendRequestFieldNumber = 15;

 private:
  const ::proto::ResumeSendRequest& _internal_resume_send_request() const;

 public:
  const ::proto::ResumeSendRequest& resume_send_request() const;
  ::proto::ResumeSendRequest* release_resume_send_request();
  ::proto::ResumeSendRequest* mutable_resume_send_request();
  void set_allocated_resume_send_request(
      ::proto::ResumeSendRequest* resume_send_request);

  // optional .proto.ResumeSendResponse resume_send_response = 16;
  bool has_resume_send_response() const;
  void clear_resume_send_response();
  static const int kResumeSendResponseFieldNumber = 16;

 private:
  const ::proto::ResumeSendResponse& _internal_resume_send_response() const;

 public:
  const ::proto::ResumeSendResponse& resume_send_response() const;
  ::proto::ResumeSendResponse* release_resume_send_response();
  ::proto::ResumeSendResponse* mutable_resume_send_response();
  void set_allocated_resume_send_response(
      ::proto::ResumeSendResponse* resume_send_response);

  // @@protoc_insertion_point(class_scope:proto.Body)
 private:
  void set_has_listen_request();
  void clear_has_listen_request();
  void set_has_listen_response();
  void clear_has_listen_response();
  void set_has_ping();
  void clear_has_ping();
  void set_has_pong();
  void clear_has_pong();
  void set_has_logout_request();
  void clear_has_logout_request();
  void set_has_logout_response();
  void clear_has_logout_response();
  void set_has_new_connection_request();
  void clear_has_new_connection_request();
  void set_has_new_connection_response();
  void clear_has_new_connection_response();
  void set_has_close_connection_request();
  void clear_has_close_connection_request();
  void set_has_close_connection_response();
  void clear_has_close_connection_response();
  void set_has_data_request();
  void clear_has_data_request();
  void set_has_data_response();
  void clear_has_data_response();
  void set_has_pause_send_request();
  void clear_has_pause_send_request();
  void set_has_pause_send_response();
  void clear_has_pause_send_response();
  void set_has_resume_send_request();
  void clear_has_resume_send_request();
  void set_has_resume_send_response();
  void clear_has_resume_send_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ListenRequest* listen_request_;
  ::proto::ListenResponse* listen_response_;
  ::proto::Ping* ping_;
  ::proto::Pong* pong_;
  ::proto::LogoutRequest* logout_request_;
  ::proto::LogoutResponse* logout_response_;
  ::proto::NewConnectionRequest* new_connection_request_;
  ::proto::NewConnectionResponse* new_connection_response_;
  ::proto::CloseConnectionRequest* close_connection_request_;
  ::proto::CloseConnectionResponse* close_connection_response_;
  ::proto::DataRequest* data_request_;
  ::proto::DataResponse* data_response_;
  ::proto::PauseSendRequest* pause_send_request_;
  ::proto::PauseSendResponse* pause_send_response_;
  ::proto::ResumeSendRequest* resume_send_request_;
  ::proto::ResumeSendResponse* resume_send_response_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseCode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ResponseCode)
                                                         */
{
 public:
  ResponseCode();
  virtual ~ResponseCode();

  ResponseCode(const ResponseCode& from);

  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ResponseCode(ResponseCode&& from) noexcept : ResponseCode() {
    *this = ::std::move(from);
  }

  inline ResponseCode& operator=(ResponseCode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCode* internal_default_instance() {
    return reinterpret_cast<const ResponseCode*>(
        &_ResponseCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;

  void Swap(ResponseCode* other);
  friend void swap(ResponseCode& a, ResponseCode& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ResponseCode* New() const final {
    return CreateMaybeMessage<ResponseCode>(NULL);
  }

  ResponseCode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseCode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCode* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error_message = 2;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
#if LANG_CXX11
  void set_error_message(::std::string&& value);
#endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // required int32 retcode = 1;
  bool has_retcode() const;
  void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  ::google::protobuf::int32 retcode() const;
  void set_retcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.ResponseCode)
 private:
  void set_has_retcode();
  void clear_has_retcode();
  void set_has_error_message();
  void clear_has_error_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::int32 retcode_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListenRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ListenRequest)
                                                          */
{
 public:
  ListenRequest();
  virtual ~ListenRequest();

  ListenRequest(const ListenRequest& from);

  inline ListenRequest& operator=(const ListenRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ListenRequest(ListenRequest&& from) noexcept : ListenRequest() {
    *this = ::std::move(from);
  }

  inline ListenRequest& operator=(ListenRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenRequest* internal_default_instance() {
    return reinterpret_cast<const ListenRequest*>(
        &_ListenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;

  void Swap(ListenRequest* other);
  friend void swap(ListenRequest& a, ListenRequest& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ListenRequest* New() const final {
    return CreateMaybeMessage<ListenRequest>(NULL);
  }

  ListenRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenRequest& from);
  void MergeFrom(const ListenRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes self_ipv6 = 2;
  int self_ipv6_size() const;
  void clear_self_ipv6();
  static const int kSelfIpv6FieldNumber = 2;
  const ::std::string& self_ipv6(int index) const;
  ::std::string* mutable_self_ipv6(int index);
  void set_self_ipv6(int index, const ::std::string& value);
#if LANG_CXX11
  void set_self_ipv6(int index, ::std::string&& value);
#endif
  void set_self_ipv6(int index, const char* value);
  void set_self_ipv6(int index, const void* value, size_t size);
  ::std::string* add_self_ipv6();
  void add_self_ipv6(const ::std::string& value);
#if LANG_CXX11
  void add_self_ipv6(::std::string&& value);
#endif
  void add_self_ipv6(const char* value);
  void add_self_ipv6(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& self_ipv6() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_self_ipv6();

  // optional uint32 self_ipv4 = 1;
  bool has_self_ipv4() const;
  void clear_self_ipv4();
  static const int kSelfIpv4FieldNumber = 1;
  ::google::protobuf::uint32 self_ipv4() const;
  void set_self_ipv4(::google::protobuf::uint32 value);

  // required uint32 self_port = 3;
  bool has_self_port() const;
  void clear_self_port();
  static const int kSelfPortFieldNumber = 3;
  ::google::protobuf::uint32 self_port() const;
  void set_self_port(::google::protobuf::uint32 value);

  // required uint32 listen_port = 4;
  bool has_listen_port() const;
  void clear_listen_port();
  static const int kListenPortFieldNumber = 4;
  ::google::protobuf::uint32 listen_port() const;
  void set_listen_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.ListenRequest)
 private:
  void set_has_self_ipv4();
  void clear_has_self_ipv4();
  void set_has_self_port();
  void clear_has_self_port();
  void set_has_listen_port();
  void clear_has_listen_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> self_ipv6_;
  ::google::protobuf::uint32 self_ipv4_;
  ::google::protobuf::uint32 self_port_;
  ::google::protobuf::uint32 listen_port_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListenResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ListenResponse)
                                                           */
{
 public:
  ListenResponse();
  virtual ~ListenResponse();

  ListenResponse(const ListenResponse& from);

  inline ListenResponse& operator=(const ListenResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ListenResponse(ListenResponse&& from) noexcept : ListenResponse() {
    *this = ::std::move(from);
  }

  inline ListenResponse& operator=(ListenResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenResponse* internal_default_instance() {
    return reinterpret_cast<const ListenResponse*>(
        &_ListenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;

  void Swap(ListenResponse* other);
  friend void swap(ListenResponse& a, ListenResponse& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ListenResponse* New() const final {
    return CreateMaybeMessage<ListenResponse>(NULL);
  }

  ListenResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenResponse& from);
  void MergeFrom(const ListenResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // optional uint64 session_key = 2;
  bool has_session_key() const;
  void clear_session_key();
  static const int kSessionKeyFieldNumber = 2;
  ::google::protobuf::uint64 session_key() const;
  void set_session_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.ListenResponse)
 private:
  void set_has_rc();
  void clear_has_rc();
  void set_has_session_key();
  void clear_has_session_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  ::google::protobuf::uint64 session_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ping
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:proto.Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Ping(Ping&& from) noexcept : Ping() { *this = ::std::move(from); }

  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(&_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;

  void Swap(Ping* other);
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Ping* New() const final { return CreateMaybeMessage<Ping>(NULL); }

  Ping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ping)
 private:
  void set_has_time();
  void clear_has_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 time_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pong
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:proto.Pong) */ {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Pong(Pong&& from) noexcept : Pong() { *this = ::std::move(from); }

  inline Pong& operator=(Pong&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(&_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;

  void Swap(Pong* other);
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Pong* New() const final { return CreateMaybeMessage<Pong>(NULL); }

  Pong* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pong* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // required uint64 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Pong)
 private:
  void set_has_rc();
  void clear_has_rc();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  ::google::protobuf::uint64 time_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.LogoutRequest)
                                                          */
{
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  LogoutRequest(LogoutRequest&& from) noexcept : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
        &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;

  void Swap(LogoutRequest* other);
  friend void swap(LogoutRequest& a, LogoutRequest& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline LogoutRequest* New() const final {
    return CreateMaybeMessage<LogoutRequest>(NULL);
  }

  LogoutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.LogoutRequest)
 private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.LogoutResponse)
                                                           */
{
 public:
  LogoutResponse();
  virtual ~LogoutResponse();

  LogoutResponse(const LogoutResponse& from);

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  LogoutResponse(LogoutResponse&& from) noexcept : LogoutResponse() {
    *this = ::std::move(from);
  }

  inline LogoutResponse& operator=(LogoutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutResponse* internal_default_instance() {
    return reinterpret_cast<const LogoutResponse*>(
        &_LogoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;

  void Swap(LogoutResponse* other);
  friend void swap(LogoutResponse& a, LogoutResponse& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline LogoutResponse* New() const final {
    return CreateMaybeMessage<LogoutResponse>(NULL);
  }

  LogoutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogoutResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogoutResponse& from);
  void MergeFrom(const LogoutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.LogoutResponse)
 private:
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewConnectionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.NewConnectionRequest)
                                                                 */
{
 public:
  NewConnectionRequest();
  virtual ~NewConnectionRequest();

  NewConnectionRequest(const NewConnectionRequest& from);

  inline NewConnectionRequest& operator=(const NewConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  NewConnectionRequest(NewConnectionRequest&& from) noexcept
      : NewConnectionRequest() {
    *this = ::std::move(from);
  }

  inline NewConnectionRequest& operator=(NewConnectionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewConnectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const NewConnectionRequest*>(
        &_NewConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;

  void Swap(NewConnectionRequest* other);
  friend void swap(NewConnectionRequest& a, NewConnectionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewConnectionRequest* New() const final {
    return CreateMaybeMessage<NewConnectionRequest>(NULL);
  }

  NewConnectionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewConnectionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewConnectionRequest& from);
  void MergeFrom(const NewConnectionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewConnectionRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes ip_v6 = 2;
  int ip_v6_size() const;
  void clear_ip_v6();
  static const int kIpV6FieldNumber = 2;
  const ::std::string& ip_v6(int index) const;
  ::std::string* mutable_ip_v6(int index);
  void set_ip_v6(int index, const ::std::string& value);
#if LANG_CXX11
  void set_ip_v6(int index, ::std::string&& value);
#endif
  void set_ip_v6(int index, const char* value);
  void set_ip_v6(int index, const void* value, size_t size);
  ::std::string* add_ip_v6();
  void add_ip_v6(const ::std::string& value);
#if LANG_CXX11
  void add_ip_v6(::std::string&& value);
#endif
  void add_ip_v6(const char* value);
  void add_ip_v6(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& ip_v6() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_ip_v6();

  // optional uint32 ip_v4 = 1;
  bool has_ip_v4() const;
  void clear_ip_v4();
  static const int kIpV4FieldNumber = 1;
  ::google::protobuf::uint32 ip_v4() const;
  void set_ip_v4(::google::protobuf::uint32 value);

  // required uint32 port = 3;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // required uint64 conn_key = 4;
  bool has_conn_key() const;
  void clear_conn_key();
  static const int kConnKeyFieldNumber = 4;
  ::google::protobuf::uint64 conn_key() const;
  void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.NewConnectionRequest)
 private:
  void set_has_ip_v4();
  void clear_has_ip_v4();
  void set_has_port();
  void clear_has_port();
  void set_has_conn_key();
  void clear_has_conn_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> ip_v6_;
  ::google::protobuf::uint32 ip_v4_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 conn_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewConnectionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.NewConnectionResponse)
                                                                  */
{
 public:
  NewConnectionResponse();
  virtual ~NewConnectionResponse();

  NewConnectionResponse(const NewConnectionResponse& from);

  inline NewConnectionResponse& operator=(const NewConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  NewConnectionResponse(NewConnectionResponse&& from) noexcept
      : NewConnectionResponse() {
    *this = ::std::move(from);
  }

  inline NewConnectionResponse& operator=(
      NewConnectionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewConnectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewConnectionResponse* internal_default_instance() {
    return reinterpret_cast<const NewConnectionResponse*>(
        &_NewConnectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;

  void Swap(NewConnectionResponse* other);
  friend void swap(NewConnectionResponse& a, NewConnectionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewConnectionResponse* New() const final {
    return CreateMaybeMessage<NewConnectionResponse>(NULL);
  }

  NewConnectionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewConnectionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewConnectionResponse& from);
  void MergeFrom(const NewConnectionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewConnectionResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.NewConnectionResponse)
 private:
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseConnectionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.CloseConnectionRequest)
                                                                   */
{
 public:
  CloseConnectionRequest();
  virtual ~CloseConnectionRequest();

  CloseConnectionRequest(const CloseConnectionRequest& from);

  inline CloseConnectionRequest& operator=(const CloseConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  CloseConnectionRequest(CloseConnectionRequest&& from) noexcept
      : CloseConnectionRequest() {
    *this = ::std::move(from);
  }

  inline CloseConnectionRequest& operator=(
      CloseConnectionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseConnectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const CloseConnectionRequest*>(
        &_CloseConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;

  void Swap(CloseConnectionRequest* other);
  friend void swap(CloseConnectionRequest& a, CloseConnectionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseConnectionRequest* New() const final {
    return CreateMaybeMessage<CloseConnectionRequest>(NULL);
  }

  CloseConnectionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseConnectionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseConnectionRequest& from);
  void MergeFrom(const CloseConnectionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseConnectionRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 conn_key = 1;
  bool has_conn_key() const;
  void clear_conn_key();
  static const int kConnKeyFieldNumber = 1;
  ::google::protobuf::uint64 conn_key() const;
  void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.CloseConnectionRequest)
 private:
  void set_has_conn_key();
  void clear_has_conn_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 conn_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseConnectionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.CloseConnectionResponse)
                                                                    */
{
 public:
  CloseConnectionResponse();
  virtual ~CloseConnectionResponse();

  CloseConnectionResponse(const CloseConnectionResponse& from);

  inline CloseConnectionResponse& operator=(
      const CloseConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  CloseConnectionResponse(CloseConnectionResponse&& from) noexcept
      : CloseConnectionResponse() {
    *this = ::std::move(from);
  }

  inline CloseConnectionResponse& operator=(
      CloseConnectionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseConnectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseConnectionResponse* internal_default_instance() {
    return reinterpret_cast<const CloseConnectionResponse*>(
        &_CloseConnectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;

  void Swap(CloseConnectionResponse* other);
  friend void swap(CloseConnectionResponse& a, CloseConnectionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseConnectionResponse* New() const final {
    return CreateMaybeMessage<CloseConnectionResponse>(NULL);
  }

  CloseConnectionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseConnectionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseConnectionResponse& from);
  void MergeFrom(const CloseConnectionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseConnectionResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.CloseConnectionResponse)
 private:
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.DataRequest)
                                                        */
{
 public:
  DataRequest();
  virtual ~DataRequest();

  DataRequest(const DataRequest& from);

  inline DataRequest& operator=(const DataRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  DataRequest(DataRequest&& from) noexcept : DataRequest() {
    *this = ::std::move(from);
  }

  inline DataRequest& operator=(DataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataRequest* internal_default_instance() {
    return reinterpret_cast<const DataRequest*>(
        &_DataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;

  void Swap(DataRequest* other);
  friend void swap(DataRequest& a, DataRequest& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline DataRequest* New() const final {
    return CreateMaybeMessage<DataRequest>(NULL);
  }

  DataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataRequest& from);
  void MergeFrom(const DataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data(int index) const;
  ::std::string* mutable_data(int index);
  void set_data(int index, const ::std::string& value);
#if LANG_CXX11
  void set_data(int index, ::std::string&& value);
#endif
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  ::std::string* add_data();
  void add_data(const ::std::string& value);
#if LANG_CXX11
  void add_data(::std::string&& value);
#endif
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& data() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_data();

  // required uint64 conn_key = 1;
  bool has_conn_key() const;
  void clear_conn_key();
  static const int kConnKeyFieldNumber = 1;
  ::google::protobuf::uint64 conn_key() const;
  void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.DataRequest)
 private:
  void set_has_conn_key();
  void clear_has_conn_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> data_;
  ::google::protobuf::uint64 conn_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.DataResponse)
                                                         */
{
 public:
  DataResponse();
  virtual ~DataResponse();

  DataResponse(const DataResponse& from);

  inline DataResponse& operator=(const DataResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  DataResponse(DataResponse&& from) noexcept : DataResponse() {
    *this = ::std::move(from);
  }

  inline DataResponse& operator=(DataResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataResponse* internal_default_instance() {
    return reinterpret_cast<const DataResponse*>(
        &_DataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;

  void Swap(DataResponse* other);
  friend void swap(DataResponse& a, DataResponse& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline DataResponse* New() const final {
    return CreateMaybeMessage<DataResponse>(NULL);
  }

  DataResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataResponse& from);
  void MergeFrom(const DataResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.DataResponse)
 private:
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PauseSendRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.PauseSendRequest)
                                                             */
{
 public:
  PauseSendRequest();
  virtual ~PauseSendRequest();

  PauseSendRequest(const PauseSendRequest& from);

  inline PauseSendRequest& operator=(const PauseSendRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  PauseSendRequest(PauseSendRequest&& from) noexcept : PauseSendRequest() {
    *this = ::std::move(from);
  }

  inline PauseSendRequest& operator=(PauseSendRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PauseSendRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PauseSendRequest* internal_default_instance() {
    return reinterpret_cast<const PauseSendRequest*>(
        &_PauseSendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;

  void Swap(PauseSendRequest* other);
  friend void swap(PauseSendRequest& a, PauseSendRequest& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline PauseSendRequest* New() const final {
    return CreateMaybeMessage<PauseSendRequest>(NULL);
  }

  PauseSendRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PauseSendRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PauseSendRequest& from);
  void MergeFrom(const PauseSendRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseSendRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 conn_key = 1;
  bool has_conn_key() const;
  void clear_conn_key();
  static const int kConnKeyFieldNumber = 1;
  ::google::protobuf::uint64 conn_key() const;
  void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.PauseSendRequest)
 private:
  void set_has_conn_key();
  void clear_has_conn_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 conn_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PauseSendResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.PauseSendResponse)
                                                              */
{
 public:
  PauseSendResponse();
  virtual ~PauseSendResponse();

  PauseSendResponse(const PauseSendResponse& from);

  inline PauseSendResponse& operator=(const PauseSendResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  PauseSendResponse(PauseSendResponse&& from) noexcept : PauseSendResponse() {
    *this = ::std::move(from);
  }

  inline PauseSendResponse& operator=(PauseSendResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PauseSendResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PauseSendResponse* internal_default_instance() {
    return reinterpret_cast<const PauseSendResponse*>(
        &_PauseSendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;

  void Swap(PauseSendResponse* other);
  friend void swap(PauseSendResponse& a, PauseSendResponse& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline PauseSendResponse* New() const final {
    return CreateMaybeMessage<PauseSendResponse>(NULL);
  }

  PauseSendResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PauseSendResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PauseSendResponse& from);
  void MergeFrom(const PauseSendResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseSendResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.PauseSendResponse)
 private:
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResumeSendRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ResumeSendRequest)
                                                              */
{
 public:
  ResumeSendRequest();
  virtual ~ResumeSendRequest();

  ResumeSendRequest(const ResumeSendRequest& from);

  inline ResumeSendRequest& operator=(const ResumeSendRequest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ResumeSendRequest(ResumeSendRequest&& from) noexcept : ResumeSendRequest() {
    *this = ::std::move(from);
  }

  inline ResumeSendRequest& operator=(ResumeSendRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResumeSendRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResumeSendRequest* internal_default_instance() {
    return reinterpret_cast<const ResumeSendRequest*>(
        &_ResumeSendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;

  void Swap(ResumeSendRequest* other);
  friend void swap(ResumeSendRequest& a, ResumeSendRequest& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ResumeSendRequest* New() const final {
    return CreateMaybeMessage<ResumeSendRequest>(NULL);
  }

  ResumeSendRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResumeSendRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResumeSendRequest& from);
  void MergeFrom(const ResumeSendRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResumeSendRequest* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 conn_key = 1;
  bool has_conn_key() const;
  void clear_conn_key();
  static const int kConnKeyFieldNumber = 1;
  ::google::protobuf::uint64 conn_key() const;
  void set_conn_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.ResumeSendRequest)
 private:
  void set_has_conn_key();
  void clear_has_conn_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 conn_key_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResumeSendResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ResumeSendResponse)
                                                               */
{
 public:
  ResumeSendResponse();
  virtual ~ResumeSendResponse();

  ResumeSendResponse(const ResumeSendResponse& from);

  inline ResumeSendResponse& operator=(const ResumeSendResponse& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ResumeSendResponse(ResumeSendResponse&& from) noexcept
      : ResumeSendResponse() {
    *this = ::std::move(from);
  }

  inline ResumeSendResponse& operator=(ResumeSendResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResumeSendResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResumeSendResponse* internal_default_instance() {
    return reinterpret_cast<const ResumeSendResponse*>(
        &_ResumeSendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;

  void Swap(ResumeSendResponse* other);
  friend void swap(ResumeSendResponse& a, ResumeSendResponse& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ResumeSendResponse* New() const final {
    return CreateMaybeMessage<ResumeSendResponse>(NULL);
  }

  ResumeSendResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResumeSendResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResumeSendResponse& from);
  void MergeFrom(const ResumeSendResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResumeSendResponse* other);

 private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ResponseCode rc = 1;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 1;

 private:
  const ::proto::ResponseCode& _internal_rc() const;

 public:
  const ::proto::ResponseCode& rc() const;
  ::proto::ResponseCode* release_rc();
  ::proto::ResponseCode* mutable_rc();
  void set_allocated_rc(::proto::ResponseCode* rc);

  // @@protoc_insertion_point(class_scope:proto.ResumeSendResponse)
 private:
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::ResponseCode* rc_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// required .proto.Head head = 1;
inline bool Message::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_head() { _has_bits_[0] |= 0x00000001u; }
inline void Message::clear_has_head() { _has_bits_[0] &= ~0x00000001u; }
inline void Message::clear_head() {
  if (head_ != NULL) head_->Clear();
  clear_has_head();
}
inline const ::proto::Head& Message::_internal_head() const { return *head_; }
inline const ::proto::Head& Message::head() const {
  const ::proto::Head* p = head_;
  // @@protoc_insertion_point(field_get:proto.Message.head)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::Head*>(
                         &::proto::_Head_default_instance_);
}
inline ::proto::Head* Message::release_head() {
  // @@protoc_insertion_point(field_release:proto.Message.head)
  clear_has_head();
  ::proto::Head* temp = head_;
  head_ = NULL;
  return temp;
}
inline ::proto::Head* Message::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::Head>(GetArenaNoVirtual());
    head_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Message.head)
  return head_;
}
inline void Message::set_allocated_head(::proto::Head* head) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete head_;
  }
  if (head) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      head = ::google::protobuf::internal::GetOwnedMessage(message_arena, head,
                                                           submessage_arena);
    }
    set_has_head();
  } else {
    clear_has_head();
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.head)
}

// required .proto.Body body = 2;
inline bool Message::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_body() { _has_bits_[0] |= 0x00000002u; }
inline void Message::clear_has_body() { _has_bits_[0] &= ~0x00000002u; }
inline void Message::clear_body() {
  if (body_ != NULL) body_->Clear();
  clear_has_body();
}
inline const ::proto::Body& Message::_internal_body() const { return *body_; }
inline const ::proto::Body& Message::body() const {
  const ::proto::Body* p = body_;
  // @@protoc_insertion_point(field_get:proto.Message.body)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::Body*>(
                         &::proto::_Body_default_instance_);
}
inline ::proto::Body* Message::release_body() {
  // @@protoc_insertion_point(field_release:proto.Message.body)
  clear_has_body();
  ::proto::Body* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::proto::Body* Message::mutable_body() {
  set_has_body();
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::Body>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Message.body)
  return body_;
}
inline void Message::set_allocated_body(::proto::Body* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(message_arena, body,
                                                           submessage_arena);
    }
    set_has_body();
  } else {
    clear_has_body();
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.body)
}

// -------------------------------------------------------------------

// Head

// required uint32 version = 1;
inline bool Head::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_version() { _has_bits_[0] |= 0x00000004u; }
inline void Head::clear_has_version() { _has_bits_[0] &= ~0x00000004u; }
inline void Head::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Head::version() const {
  // @@protoc_insertion_point(field_get:proto.Head.version)
  return version_;
}
inline void Head::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.version)
}

// required uint32 random_num = 2;
inline bool Head::has_random_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Head::set_has_random_num() { _has_bits_[0] |= 0x00000008u; }
inline void Head::clear_has_random_num() { _has_bits_[0] &= ~0x00000008u; }
inline void Head::clear_random_num() {
  random_num_ = 0u;
  clear_has_random_num();
}
inline ::google::protobuf::uint32 Head::random_num() const {
  // @@protoc_insertion_point(field_get:proto.Head.random_num)
  return random_num_;
}
inline void Head::set_random_num(::google::protobuf::uint32 value) {
  set_has_random_num();
  random_num_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.random_num)
}

// required uint32 flow_no = 3;
inline bool Head::has_flow_no() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Head::set_has_flow_no() { _has_bits_[0] |= 0x00000010u; }
inline void Head::clear_has_flow_no() { _has_bits_[0] &= ~0x00000010u; }
inline void Head::clear_flow_no() {
  flow_no_ = 0u;
  clear_has_flow_no();
}
inline ::google::protobuf::uint32 Head::flow_no() const {
  // @@protoc_insertion_point(field_get:proto.Head.flow_no)
  return flow_no_;
}
inline void Head::set_flow_no(::google::protobuf::uint32 value) {
  set_has_flow_no();
  flow_no_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.flow_no)
}

// required int32 message_type = 4;
inline bool Head::has_message_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Head::set_has_message_type() { _has_bits_[0] |= 0x00000020u; }
inline void Head::clear_has_message_type() { _has_bits_[0] &= ~0x00000020u; }
inline void Head::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 Head::message_type() const {
  // @@protoc_insertion_point(field_get:proto.Head.message_type)
  return message_type_;
}
inline void Head::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.message_type)
}

// required uint32 source_entity = 5;
inline bool Head::has_source_entity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Head::set_has_source_entity() { _has_bits_[0] |= 0x00000040u; }
inline void Head::clear_has_source_entity() { _has_bits_[0] &= ~0x00000040u; }
inline void Head::clear_source_entity() {
  source_entity_ = 0u;
  clear_has_source_entity();
}
inline ::google::protobuf::uint32 Head::source_entity() const {
  // @@protoc_insertion_point(field_get:proto.Head.source_entity)
  return source_entity_;
}
inline void Head::set_source_entity(::google::protobuf::uint32 value) {
  set_has_source_entity();
  source_entity_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.source_entity)
}

// optional uint32 dest_entity = 6;
inline bool Head::has_dest_entity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Head::set_has_dest_entity() { _has_bits_[0] |= 0x00000080u; }
inline void Head::clear_has_dest_entity() { _has_bits_[0] &= ~0x00000080u; }
inline void Head::clear_dest_entity() {
  dest_entity_ = 0u;
  clear_has_dest_entity();
}
inline ::google::protobuf::uint32 Head::dest_entity() const {
  // @@protoc_insertion_point(field_get:proto.Head.dest_entity)
  return dest_entity_;
}
inline void Head::set_dest_entity(::google::protobuf::uint32 value) {
  set_has_dest_entity();
  dest_entity_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.dest_entity)
}

// optional string call_purpose = 7;
inline bool Head::has_call_purpose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_call_purpose() { _has_bits_[0] |= 0x00000001u; }
inline void Head::clear_has_call_purpose() { _has_bits_[0] &= ~0x00000001u; }
inline void Head::clear_call_purpose() {
  call_purpose_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_call_purpose();
}
inline const ::std::string& Head::call_purpose() const {
  // @@protoc_insertion_point(field_get:proto.Head.call_purpose)
  return call_purpose_.GetNoArena();
}
inline void Head::set_call_purpose(const ::std::string& value) {
  set_has_call_purpose();
  call_purpose_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Head.call_purpose)
}
#if LANG_CXX11
inline void Head::set_call_purpose(::std::string&& value) {
  set_has_call_purpose();
  call_purpose_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Head.call_purpose)
}
#endif
inline void Head::set_call_purpose(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_call_purpose();
  call_purpose_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Head.call_purpose)
}
inline void Head::set_call_purpose(const char* value, size_t size) {
  set_has_call_purpose();
  call_purpose_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Head.call_purpose)
}
inline ::std::string* Head::mutable_call_purpose() {
  set_has_call_purpose();
  // @@protoc_insertion_point(field_mutable:proto.Head.call_purpose)
  return call_purpose_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Head::release_call_purpose() {
  // @@protoc_insertion_point(field_release:proto.Head.call_purpose)
  if (!has_call_purpose()) {
    return NULL;
  }
  clear_has_call_purpose();
  return call_purpose_.ReleaseNonDefaultNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_allocated_call_purpose(::std::string* call_purpose) {
  if (call_purpose != NULL) {
    set_has_call_purpose();
  } else {
    clear_has_call_purpose();
  }
  call_purpose_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      call_purpose);
  // @@protoc_insertion_point(field_set_allocated:proto.Head.call_purpose)
}

// optional string auth_key = 8;
inline bool Head::has_auth_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_auth_key() { _has_bits_[0] |= 0x00000002u; }
inline void Head::clear_has_auth_key() { _has_bits_[0] &= ~0x00000002u; }
inline void Head::clear_auth_key() {
  auth_key_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_auth_key();
}
inline const ::std::string& Head::auth_key() const {
  // @@protoc_insertion_point(field_get:proto.Head.auth_key)
  return auth_key_.GetNoArena();
}
inline void Head::set_auth_key(const ::std::string& value) {
  set_has_auth_key();
  auth_key_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Head.auth_key)
}
#if LANG_CXX11
inline void Head::set_auth_key(::std::string&& value) {
  set_has_auth_key();
  auth_key_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Head.auth_key)
}
#endif
inline void Head::set_auth_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_auth_key();
  auth_key_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Head.auth_key)
}
inline void Head::set_auth_key(const char* value, size_t size) {
  set_has_auth_key();
  auth_key_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Head.auth_key)
}
inline ::std::string* Head::mutable_auth_key() {
  set_has_auth_key();
  // @@protoc_insertion_point(field_mutable:proto.Head.auth_key)
  return auth_key_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Head::release_auth_key() {
  // @@protoc_insertion_point(field_release:proto.Head.auth_key)
  if (!has_auth_key()) {
    return NULL;
  }
  clear_has_auth_key();
  return auth_key_.ReleaseNonDefaultNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Head::set_allocated_auth_key(::std::string* auth_key) {
  if (auth_key != NULL) {
    set_has_auth_key();
  } else {
    clear_has_auth_key();
  }
  auth_key_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth_key);
  // @@protoc_insertion_point(field_set_allocated:proto.Head.auth_key)
}

// optional uint64 session_key = 9;
inline bool Head::has_session_key() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Head::set_has_session_key() { _has_bits_[0] |= 0x00000100u; }
inline void Head::clear_has_session_key() { _has_bits_[0] &= ~0x00000100u; }
inline void Head::clear_session_key() {
  session_key_ = GOOGLE_ULONGLONG(0);
  clear_has_session_key();
}
inline ::google::protobuf::uint64 Head::session_key() const {
  // @@protoc_insertion_point(field_get:proto.Head.session_key)
  return session_key_;
}
inline void Head::set_session_key(::google::protobuf::uint64 value) {
  set_has_session_key();
  session_key_ = value;
  // @@protoc_insertion_point(field_set:proto.Head.session_key)
}

// -------------------------------------------------------------------

// Body

// optional .proto.ListenRequest listen_request = 1;
inline bool Body::has_listen_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Body::set_has_listen_request() { _has_bits_[0] |= 0x00000001u; }
inline void Body::clear_has_listen_request() { _has_bits_[0] &= ~0x00000001u; }
inline void Body::clear_listen_request() {
  if (listen_request_ != NULL) listen_request_->Clear();
  clear_has_listen_request();
}
inline const ::proto::ListenRequest& Body::_internal_listen_request() const {
  return *listen_request_;
}
inline const ::proto::ListenRequest& Body::listen_request() const {
  const ::proto::ListenRequest* p = listen_request_;
  // @@protoc_insertion_point(field_get:proto.Body.listen_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ListenRequest*>(
                         &::proto::_ListenRequest_default_instance_);
}
inline ::proto::ListenRequest* Body::release_listen_request() {
  // @@protoc_insertion_point(field_release:proto.Body.listen_request)
  clear_has_listen_request();
  ::proto::ListenRequest* temp = listen_request_;
  listen_request_ = NULL;
  return temp;
}
inline ::proto::ListenRequest* Body::mutable_listen_request() {
  set_has_listen_request();
  if (listen_request_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ListenRequest>(GetArenaNoVirtual());
    listen_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.listen_request)
  return listen_request_;
}
inline void Body::set_allocated_listen_request(
    ::proto::ListenRequest* listen_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete listen_request_;
  }
  if (listen_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      listen_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, listen_request, submessage_arena);
    }
    set_has_listen_request();
  } else {
    clear_has_listen_request();
  }
  listen_request_ = listen_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.listen_request)
}

// optional .proto.ListenResponse listen_response = 2;
inline bool Body::has_listen_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Body::set_has_listen_response() { _has_bits_[0] |= 0x00000002u; }
inline void Body::clear_has_listen_response() { _has_bits_[0] &= ~0x00000002u; }
inline void Body::clear_listen_response() {
  if (listen_response_ != NULL) listen_response_->Clear();
  clear_has_listen_response();
}
inline const ::proto::ListenResponse& Body::_internal_listen_response() const {
  return *listen_response_;
}
inline const ::proto::ListenResponse& Body::listen_response() const {
  const ::proto::ListenResponse* p = listen_response_;
  // @@protoc_insertion_point(field_get:proto.Body.listen_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ListenResponse*>(
                         &::proto::_ListenResponse_default_instance_);
}
inline ::proto::ListenResponse* Body::release_listen_response() {
  // @@protoc_insertion_point(field_release:proto.Body.listen_response)
  clear_has_listen_response();
  ::proto::ListenResponse* temp = listen_response_;
  listen_response_ = NULL;
  return temp;
}
inline ::proto::ListenResponse* Body::mutable_listen_response() {
  set_has_listen_response();
  if (listen_response_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ListenResponse>(GetArenaNoVirtual());
    listen_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.listen_response)
  return listen_response_;
}
inline void Body::set_allocated_listen_response(
    ::proto::ListenResponse* listen_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete listen_response_;
  }
  if (listen_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      listen_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, listen_response, submessage_arena);
    }
    set_has_listen_response();
  } else {
    clear_has_listen_response();
  }
  listen_response_ = listen_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.listen_response)
}

// optional .proto.Ping ping = 3;
inline bool Body::has_ping() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Body::set_has_ping() { _has_bits_[0] |= 0x00000004u; }
inline void Body::clear_has_ping() { _has_bits_[0] &= ~0x00000004u; }
inline void Body::clear_ping() {
  if (ping_ != NULL) ping_->Clear();
  clear_has_ping();
}
inline const ::proto::Ping& Body::_internal_ping() const { return *ping_; }
inline const ::proto::Ping& Body::ping() const {
  const ::proto::Ping* p = ping_;
  // @@protoc_insertion_point(field_get:proto.Body.ping)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::Ping*>(
                         &::proto::_Ping_default_instance_);
}
inline ::proto::Ping* Body::release_ping() {
  // @@protoc_insertion_point(field_release:proto.Body.ping)
  clear_has_ping();
  ::proto::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline ::proto::Ping* Body::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::Ping>(GetArenaNoVirtual());
    ping_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.ping)
  return ping_;
}
inline void Body::set_allocated_ping(::proto::Ping* ping) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ping_;
  }
  if (ping) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ping = ::google::protobuf::internal::GetOwnedMessage(message_arena, ping,
                                                           submessage_arena);
    }
    set_has_ping();
  } else {
    clear_has_ping();
  }
  ping_ = ping;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.ping)
}

// optional .proto.Pong pong = 4;
inline bool Body::has_pong() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Body::set_has_pong() { _has_bits_[0] |= 0x00000008u; }
inline void Body::clear_has_pong() { _has_bits_[0] &= ~0x00000008u; }
inline void Body::clear_pong() {
  if (pong_ != NULL) pong_->Clear();
  clear_has_pong();
}
inline const ::proto::Pong& Body::_internal_pong() const { return *pong_; }
inline const ::proto::Pong& Body::pong() const {
  const ::proto::Pong* p = pong_;
  // @@protoc_insertion_point(field_get:proto.Body.pong)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::Pong*>(
                         &::proto::_Pong_default_instance_);
}
inline ::proto::Pong* Body::release_pong() {
  // @@protoc_insertion_point(field_release:proto.Body.pong)
  clear_has_pong();
  ::proto::Pong* temp = pong_;
  pong_ = NULL;
  return temp;
}
inline ::proto::Pong* Body::mutable_pong() {
  set_has_pong();
  if (pong_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::Pong>(GetArenaNoVirtual());
    pong_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.pong)
  return pong_;
}
inline void Body::set_allocated_pong(::proto::Pong* pong) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pong_;
  }
  if (pong) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pong = ::google::protobuf::internal::GetOwnedMessage(message_arena, pong,
                                                           submessage_arena);
    }
    set_has_pong();
  } else {
    clear_has_pong();
  }
  pong_ = pong;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.pong)
}

// optional .proto.LogoutRequest logout_request = 5;
inline bool Body::has_logout_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Body::set_has_logout_request() { _has_bits_[0] |= 0x00000010u; }
inline void Body::clear_has_logout_request() { _has_bits_[0] &= ~0x00000010u; }
inline void Body::clear_logout_request() {
  if (logout_request_ != NULL) logout_request_->Clear();
  clear_has_logout_request();
}
inline const ::proto::LogoutRequest& Body::_internal_logout_request() const {
  return *logout_request_;
}
inline const ::proto::LogoutRequest& Body::logout_request() const {
  const ::proto::LogoutRequest* p = logout_request_;
  // @@protoc_insertion_point(field_get:proto.Body.logout_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::LogoutRequest*>(
                         &::proto::_LogoutRequest_default_instance_);
}
inline ::proto::LogoutRequest* Body::release_logout_request() {
  // @@protoc_insertion_point(field_release:proto.Body.logout_request)
  clear_has_logout_request();
  ::proto::LogoutRequest* temp = logout_request_;
  logout_request_ = NULL;
  return temp;
}
inline ::proto::LogoutRequest* Body::mutable_logout_request() {
  set_has_logout_request();
  if (logout_request_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::LogoutRequest>(GetArenaNoVirtual());
    logout_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.logout_request)
  return logout_request_;
}
inline void Body::set_allocated_logout_request(
    ::proto::LogoutRequest* logout_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete logout_request_;
  }
  if (logout_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logout_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logout_request, submessage_arena);
    }
    set_has_logout_request();
  } else {
    clear_has_logout_request();
  }
  logout_request_ = logout_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.logout_request)
}

// optional .proto.LogoutResponse logout_response = 6;
inline bool Body::has_logout_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Body::set_has_logout_response() { _has_bits_[0] |= 0x00000020u; }
inline void Body::clear_has_logout_response() { _has_bits_[0] &= ~0x00000020u; }
inline void Body::clear_logout_response() {
  if (logout_response_ != NULL) logout_response_->Clear();
  clear_has_logout_response();
}
inline const ::proto::LogoutResponse& Body::_internal_logout_response() const {
  return *logout_response_;
}
inline const ::proto::LogoutResponse& Body::logout_response() const {
  const ::proto::LogoutResponse* p = logout_response_;
  // @@protoc_insertion_point(field_get:proto.Body.logout_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::LogoutResponse*>(
                         &::proto::_LogoutResponse_default_instance_);
}
inline ::proto::LogoutResponse* Body::release_logout_response() {
  // @@protoc_insertion_point(field_release:proto.Body.logout_response)
  clear_has_logout_response();
  ::proto::LogoutResponse* temp = logout_response_;
  logout_response_ = NULL;
  return temp;
}
inline ::proto::LogoutResponse* Body::mutable_logout_response() {
  set_has_logout_response();
  if (logout_response_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::LogoutResponse>(GetArenaNoVirtual());
    logout_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.logout_response)
  return logout_response_;
}
inline void Body::set_allocated_logout_response(
    ::proto::LogoutResponse* logout_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete logout_response_;
  }
  if (logout_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logout_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logout_response, submessage_arena);
    }
    set_has_logout_response();
  } else {
    clear_has_logout_response();
  }
  logout_response_ = logout_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.logout_response)
}

// optional .proto.NewConnectionRequest new_connection_request = 7;
inline bool Body::has_new_connection_request() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Body::set_has_new_connection_request() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Body::clear_has_new_connection_request() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Body::clear_new_connection_request() {
  if (new_connection_request_ != NULL) new_connection_request_->Clear();
  clear_has_new_connection_request();
}
inline const ::proto::NewConnectionRequest&
Body::_internal_new_connection_request() const {
  return *new_connection_request_;
}
inline const ::proto::NewConnectionRequest& Body::new_connection_request()
    const {
  const ::proto::NewConnectionRequest* p = new_connection_request_;
  // @@protoc_insertion_point(field_get:proto.Body.new_connection_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::NewConnectionRequest*>(
                         &::proto::_NewConnectionRequest_default_instance_);
}
inline ::proto::NewConnectionRequest* Body::release_new_connection_request() {
  // @@protoc_insertion_point(field_release:proto.Body.new_connection_request)
  clear_has_new_connection_request();
  ::proto::NewConnectionRequest* temp = new_connection_request_;
  new_connection_request_ = NULL;
  return temp;
}
inline ::proto::NewConnectionRequest* Body::mutable_new_connection_request() {
  set_has_new_connection_request();
  if (new_connection_request_ == NULL) {
    auto* p =
        CreateMaybeMessage<::proto::NewConnectionRequest>(GetArenaNoVirtual());
    new_connection_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.new_connection_request)
  return new_connection_request_;
}
inline void Body::set_allocated_new_connection_request(
    ::proto::NewConnectionRequest* new_connection_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete new_connection_request_;
  }
  if (new_connection_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      new_connection_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, new_connection_request, submessage_arena);
    }
    set_has_new_connection_request();
  } else {
    clear_has_new_connection_request();
  }
  new_connection_request_ = new_connection_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.new_connection_request)
}

// optional .proto.NewConnectionResponse new_connection_response = 8;
inline bool Body::has_new_connection_response() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Body::set_has_new_connection_response() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Body::clear_has_new_connection_response() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Body::clear_new_connection_response() {
  if (new_connection_response_ != NULL) new_connection_response_->Clear();
  clear_has_new_connection_response();
}
inline const ::proto::NewConnectionResponse&
Body::_internal_new_connection_response() const {
  return *new_connection_response_;
}
inline const ::proto::NewConnectionResponse& Body::new_connection_response()
    const {
  const ::proto::NewConnectionResponse* p = new_connection_response_;
  // @@protoc_insertion_point(field_get:proto.Body.new_connection_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::NewConnectionResponse*>(
                         &::proto::_NewConnectionResponse_default_instance_);
}
inline ::proto::NewConnectionResponse* Body::release_new_connection_response() {
  // @@protoc_insertion_point(field_release:proto.Body.new_connection_response)
  clear_has_new_connection_response();
  ::proto::NewConnectionResponse* temp = new_connection_response_;
  new_connection_response_ = NULL;
  return temp;
}
inline ::proto::NewConnectionResponse* Body::mutable_new_connection_response() {
  set_has_new_connection_response();
  if (new_connection_response_ == NULL) {
    auto* p =
        CreateMaybeMessage<::proto::NewConnectionResponse>(GetArenaNoVirtual());
    new_connection_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.new_connection_response)
  return new_connection_response_;
}
inline void Body::set_allocated_new_connection_response(
    ::proto::NewConnectionResponse* new_connection_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete new_connection_response_;
  }
  if (new_connection_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      new_connection_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, new_connection_response, submessage_arena);
    }
    set_has_new_connection_response();
  } else {
    clear_has_new_connection_response();
  }
  new_connection_response_ = new_connection_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.new_connection_response)
}

// optional .proto.CloseConnectionRequest close_connection_request = 9;
inline bool Body::has_close_connection_request() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Body::set_has_close_connection_request() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Body::clear_has_close_connection_request() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Body::clear_close_connection_request() {
  if (close_connection_request_ != NULL) close_connection_request_->Clear();
  clear_has_close_connection_request();
}
inline const ::proto::CloseConnectionRequest&
Body::_internal_close_connection_request() const {
  return *close_connection_request_;
}
inline const ::proto::CloseConnectionRequest& Body::close_connection_request()
    const {
  const ::proto::CloseConnectionRequest* p = close_connection_request_;
  // @@protoc_insertion_point(field_get:proto.Body.close_connection_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::CloseConnectionRequest*>(
                         &::proto::_CloseConnectionRequest_default_instance_);
}
inline ::proto::CloseConnectionRequest*
Body::release_close_connection_request() {
  // @@protoc_insertion_point(field_release:proto.Body.close_connection_request)
  clear_has_close_connection_request();
  ::proto::CloseConnectionRequest* temp = close_connection_request_;
  close_connection_request_ = NULL;
  return temp;
}
inline ::proto::CloseConnectionRequest*
Body::mutable_close_connection_request() {
  set_has_close_connection_request();
  if (close_connection_request_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::CloseConnectionRequest>(
        GetArenaNoVirtual());
    close_connection_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.close_connection_request)
  return close_connection_request_;
}
inline void Body::set_allocated_close_connection_request(
    ::proto::CloseConnectionRequest* close_connection_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete close_connection_request_;
  }
  if (close_connection_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      close_connection_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, close_connection_request, submessage_arena);
    }
    set_has_close_connection_request();
  } else {
    clear_has_close_connection_request();
  }
  close_connection_request_ = close_connection_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.close_connection_request)
}

// optional .proto.CloseConnectionResponse close_connection_response = 10;
inline bool Body::has_close_connection_response() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Body::set_has_close_connection_response() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Body::clear_has_close_connection_response() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Body::clear_close_connection_response() {
  if (close_connection_response_ != NULL) close_connection_response_->Clear();
  clear_has_close_connection_response();
}
inline const ::proto::CloseConnectionResponse&
Body::_internal_close_connection_response() const {
  return *close_connection_response_;
}
inline const ::proto::CloseConnectionResponse& Body::close_connection_response()
    const {
  const ::proto::CloseConnectionResponse* p = close_connection_response_;
  // @@protoc_insertion_point(field_get:proto.Body.close_connection_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::CloseConnectionResponse*>(
                         &::proto::_CloseConnectionResponse_default_instance_);
}
inline ::proto::CloseConnectionResponse*
Body::release_close_connection_response() {
  // @@protoc_insertion_point(field_release:proto.Body.close_connection_response)
  clear_has_close_connection_response();
  ::proto::CloseConnectionResponse* temp = close_connection_response_;
  close_connection_response_ = NULL;
  return temp;
}
inline ::proto::CloseConnectionResponse*
Body::mutable_close_connection_response() {
  set_has_close_connection_response();
  if (close_connection_response_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::CloseConnectionResponse>(
        GetArenaNoVirtual());
    close_connection_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.close_connection_response)
  return close_connection_response_;
}
inline void Body::set_allocated_close_connection_response(
    ::proto::CloseConnectionResponse* close_connection_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete close_connection_response_;
  }
  if (close_connection_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      close_connection_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, close_connection_response, submessage_arena);
    }
    set_has_close_connection_response();
  } else {
    clear_has_close_connection_response();
  }
  close_connection_response_ = close_connection_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.close_connection_response)
}

// optional .proto.DataRequest data_request = 11;
inline bool Body::has_data_request() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Body::set_has_data_request() { _has_bits_[0] |= 0x00000400u; }
inline void Body::clear_has_data_request() { _has_bits_[0] &= ~0x00000400u; }
inline void Body::clear_data_request() {
  if (data_request_ != NULL) data_request_->Clear();
  clear_has_data_request();
}
inline const ::proto::DataRequest& Body::_internal_data_request() const {
  return *data_request_;
}
inline const ::proto::DataRequest& Body::data_request() const {
  const ::proto::DataRequest* p = data_request_;
  // @@protoc_insertion_point(field_get:proto.Body.data_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::DataRequest*>(
                         &::proto::_DataRequest_default_instance_);
}
inline ::proto::DataRequest* Body::release_data_request() {
  // @@protoc_insertion_point(field_release:proto.Body.data_request)
  clear_has_data_request();
  ::proto::DataRequest* temp = data_request_;
  data_request_ = NULL;
  return temp;
}
inline ::proto::DataRequest* Body::mutable_data_request() {
  set_has_data_request();
  if (data_request_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::DataRequest>(GetArenaNoVirtual());
    data_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.data_request)
  return data_request_;
}
inline void Body::set_allocated_data_request(
    ::proto::DataRequest* data_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_request_;
  }
  if (data_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_request, submessage_arena);
    }
    set_has_data_request();
  } else {
    clear_has_data_request();
  }
  data_request_ = data_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.data_request)
}

// optional .proto.DataResponse data_response = 12;
inline bool Body::has_data_response() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Body::set_has_data_response() { _has_bits_[0] |= 0x00000800u; }
inline void Body::clear_has_data_response() { _has_bits_[0] &= ~0x00000800u; }
inline void Body::clear_data_response() {
  if (data_response_ != NULL) data_response_->Clear();
  clear_has_data_response();
}
inline const ::proto::DataResponse& Body::_internal_data_response() const {
  return *data_response_;
}
inline const ::proto::DataResponse& Body::data_response() const {
  const ::proto::DataResponse* p = data_response_;
  // @@protoc_insertion_point(field_get:proto.Body.data_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::DataResponse*>(
                         &::proto::_DataResponse_default_instance_);
}
inline ::proto::DataResponse* Body::release_data_response() {
  // @@protoc_insertion_point(field_release:proto.Body.data_response)
  clear_has_data_response();
  ::proto::DataResponse* temp = data_response_;
  data_response_ = NULL;
  return temp;
}
inline ::proto::DataResponse* Body::mutable_data_response() {
  set_has_data_response();
  if (data_response_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::DataResponse>(GetArenaNoVirtual());
    data_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.data_response)
  return data_response_;
}
inline void Body::set_allocated_data_response(
    ::proto::DataResponse* data_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_response_;
  }
  if (data_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_response, submessage_arena);
    }
    set_has_data_response();
  } else {
    clear_has_data_response();
  }
  data_response_ = data_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.data_response)
}

// optional .proto.PauseSendRequest pause_send_request = 13;
inline bool Body::has_pause_send_request() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Body::set_has_pause_send_request() { _has_bits_[0] |= 0x00001000u; }
inline void Body::clear_has_pause_send_request() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Body::clear_pause_send_request() {
  if (pause_send_request_ != NULL) pause_send_request_->Clear();
  clear_has_pause_send_request();
}
inline const ::proto::PauseSendRequest& Body::_internal_pause_send_request()
    const {
  return *pause_send_request_;
}
inline const ::proto::PauseSendRequest& Body::pause_send_request() const {
  const ::proto::PauseSendRequest* p = pause_send_request_;
  // @@protoc_insertion_point(field_get:proto.Body.pause_send_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::PauseSendRequest*>(
                         &::proto::_PauseSendRequest_default_instance_);
}
inline ::proto::PauseSendRequest* Body::release_pause_send_request() {
  // @@protoc_insertion_point(field_release:proto.Body.pause_send_request)
  clear_has_pause_send_request();
  ::proto::PauseSendRequest* temp = pause_send_request_;
  pause_send_request_ = NULL;
  return temp;
}
inline ::proto::PauseSendRequest* Body::mutable_pause_send_request() {
  set_has_pause_send_request();
  if (pause_send_request_ == NULL) {
    auto* p =
        CreateMaybeMessage<::proto::PauseSendRequest>(GetArenaNoVirtual());
    pause_send_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.pause_send_request)
  return pause_send_request_;
}
inline void Body::set_allocated_pause_send_request(
    ::proto::PauseSendRequest* pause_send_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pause_send_request_;
  }
  if (pause_send_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pause_send_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pause_send_request, submessage_arena);
    }
    set_has_pause_send_request();
  } else {
    clear_has_pause_send_request();
  }
  pause_send_request_ = pause_send_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.pause_send_request)
}

// optional .proto.PauseSendResponse pause_send_response = 14;
inline bool Body::has_pause_send_response() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Body::set_has_pause_send_response() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Body::clear_has_pause_send_response() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Body::clear_pause_send_response() {
  if (pause_send_response_ != NULL) pause_send_response_->Clear();
  clear_has_pause_send_response();
}
inline const ::proto::PauseSendResponse& Body::_internal_pause_send_response()
    const {
  return *pause_send_response_;
}
inline const ::proto::PauseSendResponse& Body::pause_send_response() const {
  const ::proto::PauseSendResponse* p = pause_send_response_;
  // @@protoc_insertion_point(field_get:proto.Body.pause_send_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::PauseSendResponse*>(
                         &::proto::_PauseSendResponse_default_instance_);
}
inline ::proto::PauseSendResponse* Body::release_pause_send_response() {
  // @@protoc_insertion_point(field_release:proto.Body.pause_send_response)
  clear_has_pause_send_response();
  ::proto::PauseSendResponse* temp = pause_send_response_;
  pause_send_response_ = NULL;
  return temp;
}
inline ::proto::PauseSendResponse* Body::mutable_pause_send_response() {
  set_has_pause_send_response();
  if (pause_send_response_ == NULL) {
    auto* p =
        CreateMaybeMessage<::proto::PauseSendResponse>(GetArenaNoVirtual());
    pause_send_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.pause_send_response)
  return pause_send_response_;
}
inline void Body::set_allocated_pause_send_response(
    ::proto::PauseSendResponse* pause_send_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pause_send_response_;
  }
  if (pause_send_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pause_send_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pause_send_response, submessage_arena);
    }
    set_has_pause_send_response();
  } else {
    clear_has_pause_send_response();
  }
  pause_send_response_ = pause_send_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.pause_send_response)
}

// optional .proto.ResumeSendRequest resume_send_request = 15;
inline bool Body::has_resume_send_request() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Body::set_has_resume_send_request() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Body::clear_has_resume_send_request() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Body::clear_resume_send_request() {
  if (resume_send_request_ != NULL) resume_send_request_->Clear();
  clear_has_resume_send_request();
}
inline const ::proto::ResumeSendRequest& Body::_internal_resume_send_request()
    const {
  return *resume_send_request_;
}
inline const ::proto::ResumeSendRequest& Body::resume_send_request() const {
  const ::proto::ResumeSendRequest* p = resume_send_request_;
  // @@protoc_insertion_point(field_get:proto.Body.resume_send_request)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResumeSendRequest*>(
                         &::proto::_ResumeSendRequest_default_instance_);
}
inline ::proto::ResumeSendRequest* Body::release_resume_send_request() {
  // @@protoc_insertion_point(field_release:proto.Body.resume_send_request)
  clear_has_resume_send_request();
  ::proto::ResumeSendRequest* temp = resume_send_request_;
  resume_send_request_ = NULL;
  return temp;
}
inline ::proto::ResumeSendRequest* Body::mutable_resume_send_request() {
  set_has_resume_send_request();
  if (resume_send_request_ == NULL) {
    auto* p =
        CreateMaybeMessage<::proto::ResumeSendRequest>(GetArenaNoVirtual());
    resume_send_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.resume_send_request)
  return resume_send_request_;
}
inline void Body::set_allocated_resume_send_request(
    ::proto::ResumeSendRequest* resume_send_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resume_send_request_;
  }
  if (resume_send_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resume_send_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resume_send_request, submessage_arena);
    }
    set_has_resume_send_request();
  } else {
    clear_has_resume_send_request();
  }
  resume_send_request_ = resume_send_request;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.resume_send_request)
}

// optional .proto.ResumeSendResponse resume_send_response = 16;
inline bool Body::has_resume_send_response() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Body::set_has_resume_send_response() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Body::clear_has_resume_send_response() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Body::clear_resume_send_response() {
  if (resume_send_response_ != NULL) resume_send_response_->Clear();
  clear_has_resume_send_response();
}
inline const ::proto::ResumeSendResponse& Body::_internal_resume_send_response()
    const {
  return *resume_send_response_;
}
inline const ::proto::ResumeSendResponse& Body::resume_send_response() const {
  const ::proto::ResumeSendResponse* p = resume_send_response_;
  // @@protoc_insertion_point(field_get:proto.Body.resume_send_response)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResumeSendResponse*>(
                         &::proto::_ResumeSendResponse_default_instance_);
}
inline ::proto::ResumeSendResponse* Body::release_resume_send_response() {
  // @@protoc_insertion_point(field_release:proto.Body.resume_send_response)
  clear_has_resume_send_response();
  ::proto::ResumeSendResponse* temp = resume_send_response_;
  resume_send_response_ = NULL;
  return temp;
}
inline ::proto::ResumeSendResponse* Body::mutable_resume_send_response() {
  set_has_resume_send_response();
  if (resume_send_response_ == NULL) {
    auto* p =
        CreateMaybeMessage<::proto::ResumeSendResponse>(GetArenaNoVirtual());
    resume_send_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Body.resume_send_response)
  return resume_send_response_;
}
inline void Body::set_allocated_resume_send_response(
    ::proto::ResumeSendResponse* resume_send_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resume_send_response_;
  }
  if (resume_send_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resume_send_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resume_send_response, submessage_arena);
    }
    set_has_resume_send_response();
  } else {
    clear_has_resume_send_response();
  }
  resume_send_response_ = resume_send_response;
  // @@protoc_insertion_point(field_set_allocated:proto.Body.resume_send_response)
}

// -------------------------------------------------------------------

// ResponseCode

// required int32 retcode = 1;
inline bool ResponseCode::has_retcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCode::set_has_retcode() { _has_bits_[0] |= 0x00000002u; }
inline void ResponseCode::clear_has_retcode() { _has_bits_[0] &= ~0x00000002u; }
inline void ResponseCode::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 ResponseCode::retcode() const {
  // @@protoc_insertion_point(field_get:proto.ResponseCode.retcode)
  return retcode_;
}
inline void ResponseCode::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
  // @@protoc_insertion_point(field_set:proto.ResponseCode.retcode)
}

// optional string error_message = 2;
inline bool ResponseCode::has_error_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_error_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCode::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCode::clear_error_message() {
  error_message_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& ResponseCode::error_message() const {
  // @@protoc_insertion_point(field_get:proto.ResponseCode.error_message)
  return error_message_.GetNoArena();
}
inline void ResponseCode::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ResponseCode.error_message)
}
#if LANG_CXX11
inline void ResponseCode::set_error_message(::std::string&& value) {
  set_has_error_message();
  error_message_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ResponseCode.error_message)
}
#endif
inline void ResponseCode::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_message();
  error_message_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ResponseCode.error_message)
}
inline void ResponseCode::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ResponseCode.error_message)
}
inline ::std::string* ResponseCode::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:proto.ResponseCode.error_message)
  return error_message_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCode::release_error_message() {
  // @@protoc_insertion_point(field_release:proto.ResponseCode.error_message)
  if (!has_error_message()) {
    return NULL;
  }
  clear_has_error_message();
  return error_message_.ReleaseNonDefaultNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCode::set_allocated_error_message(
    ::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      error_message);
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseCode.error_message)
}

// -------------------------------------------------------------------

// ListenRequest

// optional uint32 self_ipv4 = 1;
inline bool ListenRequest::has_self_ipv4() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListenRequest::set_has_self_ipv4() { _has_bits_[0] |= 0x00000001u; }
inline void ListenRequest::clear_has_self_ipv4() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListenRequest::clear_self_ipv4() {
  self_ipv4_ = 0u;
  clear_has_self_ipv4();
}
inline ::google::protobuf::uint32 ListenRequest::self_ipv4() const {
  // @@protoc_insertion_point(field_get:proto.ListenRequest.self_ipv4)
  return self_ipv4_;
}
inline void ListenRequest::set_self_ipv4(::google::protobuf::uint32 value) {
  set_has_self_ipv4();
  self_ipv4_ = value;
  // @@protoc_insertion_point(field_set:proto.ListenRequest.self_ipv4)
}

// repeated bytes self_ipv6 = 2;
inline int ListenRequest::self_ipv6_size() const { return self_ipv6_.size(); }
inline void ListenRequest::clear_self_ipv6() { self_ipv6_.Clear(); }
inline const ::std::string& ListenRequest::self_ipv6(int index) const {
  // @@protoc_insertion_point(field_get:proto.ListenRequest.self_ipv6)
  return self_ipv6_.Get(index);
}
inline ::std::string* ListenRequest::mutable_self_ipv6(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ListenRequest.self_ipv6)
  return self_ipv6_.Mutable(index);
}
inline void ListenRequest::set_self_ipv6(int index,
                                         const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.ListenRequest.self_ipv6)
  self_ipv6_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListenRequest::set_self_ipv6(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.ListenRequest.self_ipv6)
  self_ipv6_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListenRequest::set_self_ipv6(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  self_ipv6_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ListenRequest.self_ipv6)
}
inline void ListenRequest::set_self_ipv6(int index, const void* value,
                                         size_t size) {
  self_ipv6_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ListenRequest.self_ipv6)
}
inline ::std::string* ListenRequest::add_self_ipv6() {
  // @@protoc_insertion_point(field_add_mutable:proto.ListenRequest.self_ipv6)
  return self_ipv6_.Add();
}
inline void ListenRequest::add_self_ipv6(const ::std::string& value) {
  self_ipv6_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.ListenRequest.self_ipv6)
}
#if LANG_CXX11
inline void ListenRequest::add_self_ipv6(::std::string&& value) {
  self_ipv6_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.ListenRequest.self_ipv6)
}
#endif
inline void ListenRequest::add_self_ipv6(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  self_ipv6_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.ListenRequest.self_ipv6)
}
inline void ListenRequest::add_self_ipv6(const void* value, size_t size) {
  self_ipv6_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.ListenRequest.self_ipv6)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ListenRequest::self_ipv6() const {
  // @@protoc_insertion_point(field_list:proto.ListenRequest.self_ipv6)
  return self_ipv6_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ListenRequest::mutable_self_ipv6() {
  // @@protoc_insertion_point(field_mutable_list:proto.ListenRequest.self_ipv6)
  return &self_ipv6_;
}

// required uint32 self_port = 3;
inline bool ListenRequest::has_self_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListenRequest::set_has_self_port() { _has_bits_[0] |= 0x00000002u; }
inline void ListenRequest::clear_has_self_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListenRequest::clear_self_port() {
  self_port_ = 0u;
  clear_has_self_port();
}
inline ::google::protobuf::uint32 ListenRequest::self_port() const {
  // @@protoc_insertion_point(field_get:proto.ListenRequest.self_port)
  return self_port_;
}
inline void ListenRequest::set_self_port(::google::protobuf::uint32 value) {
  set_has_self_port();
  self_port_ = value;
  // @@protoc_insertion_point(field_set:proto.ListenRequest.self_port)
}

// required uint32 listen_port = 4;
inline bool ListenRequest::has_listen_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListenRequest::set_has_listen_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListenRequest::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListenRequest::clear_listen_port() {
  listen_port_ = 0u;
  clear_has_listen_port();
}
inline ::google::protobuf::uint32 ListenRequest::listen_port() const {
  // @@protoc_insertion_point(field_get:proto.ListenRequest.listen_port)
  return listen_port_;
}
inline void ListenRequest::set_listen_port(::google::protobuf::uint32 value) {
  set_has_listen_port();
  listen_port_ = value;
  // @@protoc_insertion_point(field_set:proto.ListenRequest.listen_port)
}

// -------------------------------------------------------------------

// ListenResponse

// required .proto.ResponseCode rc = 1;
inline bool ListenResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListenResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void ListenResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void ListenResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& ListenResponse::_internal_rc() const {
  return *rc_;
}
inline const ::proto::ResponseCode& ListenResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.ListenResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* ListenResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.ListenResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* ListenResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ListenResponse.rc)
  return rc_;
}
inline void ListenResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.ListenResponse.rc)
}

// optional uint64 session_key = 2;
inline bool ListenResponse::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListenResponse::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListenResponse::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListenResponse::clear_session_key() {
  session_key_ = GOOGLE_ULONGLONG(0);
  clear_has_session_key();
}
inline ::google::protobuf::uint64 ListenResponse::session_key() const {
  // @@protoc_insertion_point(field_get:proto.ListenResponse.session_key)
  return session_key_;
}
inline void ListenResponse::set_session_key(::google::protobuf::uint64 value) {
  set_has_session_key();
  session_key_ = value;
  // @@protoc_insertion_point(field_set:proto.ListenResponse.session_key)
}

// -------------------------------------------------------------------

// Ping

// required uint64 time = 1;
inline bool Ping::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_time() { _has_bits_[0] |= 0x00000001u; }
inline void Ping::clear_has_time() { _has_bits_[0] &= ~0x00000001u; }
inline void Ping::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Ping::time() const {
  // @@protoc_insertion_point(field_get:proto.Ping.time)
  return time_;
}
inline void Ping::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:proto.Ping.time)
}

// -------------------------------------------------------------------

// Pong

// required .proto.ResponseCode rc = 1;
inline bool Pong::has_rc() const { return (_has_bits_[0] & 0x00000001u) != 0; }
inline void Pong::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void Pong::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void Pong::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& Pong::_internal_rc() const { return *rc_; }
inline const ::proto::ResponseCode& Pong::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.Pong.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* Pong::release_rc() {
  // @@protoc_insertion_point(field_release:proto.Pong.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* Pong::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.Pong.rc)
  return rc_;
}
inline void Pong::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.Pong.rc)
}

// required uint64 time = 2;
inline bool Pong::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pong::set_has_time() { _has_bits_[0] |= 0x00000002u; }
inline void Pong::clear_has_time() { _has_bits_[0] &= ~0x00000002u; }
inline void Pong::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Pong::time() const {
  // @@protoc_insertion_point(field_get:proto.Pong.time)
  return time_;
}
inline void Pong::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:proto.Pong.time)
}

// -------------------------------------------------------------------

// LogoutRequest

// -------------------------------------------------------------------

// LogoutResponse

// required .proto.ResponseCode rc = 1;
inline bool LogoutResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void LogoutResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void LogoutResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& LogoutResponse::_internal_rc() const {
  return *rc_;
}
inline const ::proto::ResponseCode& LogoutResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.LogoutResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* LogoutResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.LogoutResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* LogoutResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.LogoutResponse.rc)
  return rc_;
}
inline void LogoutResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.LogoutResponse.rc)
}

// -------------------------------------------------------------------

// NewConnectionRequest

// optional uint32 ip_v4 = 1;
inline bool NewConnectionRequest::has_ip_v4() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewConnectionRequest::set_has_ip_v4() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewConnectionRequest::clear_has_ip_v4() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewConnectionRequest::clear_ip_v4() {
  ip_v4_ = 0u;
  clear_has_ip_v4();
}
inline ::google::protobuf::uint32 NewConnectionRequest::ip_v4() const {
  // @@protoc_insertion_point(field_get:proto.NewConnectionRequest.ip_v4)
  return ip_v4_;
}
inline void NewConnectionRequest::set_ip_v4(::google::protobuf::uint32 value) {
  set_has_ip_v4();
  ip_v4_ = value;
  // @@protoc_insertion_point(field_set:proto.NewConnectionRequest.ip_v4)
}

// repeated bytes ip_v6 = 2;
inline int NewConnectionRequest::ip_v6_size() const { return ip_v6_.size(); }
inline void NewConnectionRequest::clear_ip_v6() { ip_v6_.Clear(); }
inline const ::std::string& NewConnectionRequest::ip_v6(int index) const {
  // @@protoc_insertion_point(field_get:proto.NewConnectionRequest.ip_v6)
  return ip_v6_.Get(index);
}
inline ::std::string* NewConnectionRequest::mutable_ip_v6(int index) {
  // @@protoc_insertion_point(field_mutable:proto.NewConnectionRequest.ip_v6)
  return ip_v6_.Mutable(index);
}
inline void NewConnectionRequest::set_ip_v6(int index,
                                            const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.NewConnectionRequest.ip_v6)
  ip_v6_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NewConnectionRequest::set_ip_v6(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.NewConnectionRequest.ip_v6)
  ip_v6_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NewConnectionRequest::set_ip_v6(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_v6_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.NewConnectionRequest.ip_v6)
}
inline void NewConnectionRequest::set_ip_v6(int index, const void* value,
                                            size_t size) {
  ip_v6_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.NewConnectionRequest.ip_v6)
}
inline ::std::string* NewConnectionRequest::add_ip_v6() {
  // @@protoc_insertion_point(field_add_mutable:proto.NewConnectionRequest.ip_v6)
  return ip_v6_.Add();
}
inline void NewConnectionRequest::add_ip_v6(const ::std::string& value) {
  ip_v6_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.NewConnectionRequest.ip_v6)
}
#if LANG_CXX11
inline void NewConnectionRequest::add_ip_v6(::std::string&& value) {
  ip_v6_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.NewConnectionRequest.ip_v6)
}
#endif
inline void NewConnectionRequest::add_ip_v6(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_v6_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.NewConnectionRequest.ip_v6)
}
inline void NewConnectionRequest::add_ip_v6(const void* value, size_t size) {
  ip_v6_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.NewConnectionRequest.ip_v6)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
NewConnectionRequest::ip_v6() const {
  // @@protoc_insertion_point(field_list:proto.NewConnectionRequest.ip_v6)
  return ip_v6_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
NewConnectionRequest::mutable_ip_v6() {
  // @@protoc_insertion_point(field_mutable_list:proto.NewConnectionRequest.ip_v6)
  return &ip_v6_;
}

// required uint32 port = 3;
inline bool NewConnectionRequest::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewConnectionRequest::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewConnectionRequest::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewConnectionRequest::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 NewConnectionRequest::port() const {
  // @@protoc_insertion_point(field_get:proto.NewConnectionRequest.port)
  return port_;
}
inline void NewConnectionRequest::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:proto.NewConnectionRequest.port)
}

// required uint64 conn_key = 4;
inline bool NewConnectionRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewConnectionRequest::set_has_conn_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewConnectionRequest::clear_has_conn_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewConnectionRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 NewConnectionRequest::conn_key() const {
  // @@protoc_insertion_point(field_get:proto.NewConnectionRequest.conn_key)
  return conn_key_;
}
inline void NewConnectionRequest::set_conn_key(
    ::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
  // @@protoc_insertion_point(field_set:proto.NewConnectionRequest.conn_key)
}

// -------------------------------------------------------------------

// NewConnectionResponse

// required .proto.ResponseCode rc = 1;
inline bool NewConnectionResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewConnectionResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewConnectionResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewConnectionResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& NewConnectionResponse::_internal_rc()
    const {
  return *rc_;
}
inline const ::proto::ResponseCode& NewConnectionResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.NewConnectionResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* NewConnectionResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.NewConnectionResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* NewConnectionResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.NewConnectionResponse.rc)
  return rc_;
}
inline void NewConnectionResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.NewConnectionResponse.rc)
}

// -------------------------------------------------------------------

// CloseConnectionRequest

// required uint64 conn_key = 1;
inline bool CloseConnectionRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseConnectionRequest::set_has_conn_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseConnectionRequest::clear_has_conn_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseConnectionRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 CloseConnectionRequest::conn_key() const {
  // @@protoc_insertion_point(field_get:proto.CloseConnectionRequest.conn_key)
  return conn_key_;
}
inline void CloseConnectionRequest::set_conn_key(
    ::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
  // @@protoc_insertion_point(field_set:proto.CloseConnectionRequest.conn_key)
}

// -------------------------------------------------------------------

// CloseConnectionResponse

// required .proto.ResponseCode rc = 1;
inline bool CloseConnectionResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseConnectionResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseConnectionResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseConnectionResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& CloseConnectionResponse::_internal_rc()
    const {
  return *rc_;
}
inline const ::proto::ResponseCode& CloseConnectionResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.CloseConnectionResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* CloseConnectionResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.CloseConnectionResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* CloseConnectionResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.CloseConnectionResponse.rc)
  return rc_;
}
inline void CloseConnectionResponse::set_allocated_rc(
    ::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.CloseConnectionResponse.rc)
}

// -------------------------------------------------------------------

// DataRequest

// required uint64 conn_key = 1;
inline bool DataRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataRequest::set_has_conn_key() { _has_bits_[0] |= 0x00000001u; }
inline void DataRequest::clear_has_conn_key() { _has_bits_[0] &= ~0x00000001u; }
inline void DataRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 DataRequest::conn_key() const {
  // @@protoc_insertion_point(field_get:proto.DataRequest.conn_key)
  return conn_key_;
}
inline void DataRequest::set_conn_key(::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
  // @@protoc_insertion_point(field_set:proto.DataRequest.conn_key)
}

// repeated bytes data = 2;
inline int DataRequest::data_size() const { return data_.size(); }
inline void DataRequest::clear_data() { data_.Clear(); }
inline const ::std::string& DataRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:proto.DataRequest.data)
  return data_.Get(index);
}
inline ::std::string* DataRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:proto.DataRequest.data)
  return data_.Mutable(index);
}
inline void DataRequest::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.DataRequest.data)
  data_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DataRequest::set_data(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.DataRequest.data)
  data_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DataRequest::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.DataRequest.data)
}
inline void DataRequest::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.DataRequest.data)
}
inline ::std::string* DataRequest::add_data() {
  // @@protoc_insertion_point(field_add_mutable:proto.DataRequest.data)
  return data_.Add();
}
inline void DataRequest::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.DataRequest.data)
}
#if LANG_CXX11
inline void DataRequest::add_data(::std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.DataRequest.data)
}
#endif
inline void DataRequest::add_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.DataRequest.data)
}
inline void DataRequest::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.DataRequest.data)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DataRequest::data() const {
  // @@protoc_insertion_point(field_list:proto.DataRequest.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DataRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:proto.DataRequest.data)
  return &data_;
}

// -------------------------------------------------------------------

// DataResponse

// required .proto.ResponseCode rc = 1;
inline bool DataResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void DataResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void DataResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& DataResponse::_internal_rc() const {
  return *rc_;
}
inline const ::proto::ResponseCode& DataResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.DataResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* DataResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.DataResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* DataResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.DataResponse.rc)
  return rc_;
}
inline void DataResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.DataResponse.rc)
}

// -------------------------------------------------------------------

// PauseSendRequest

// required uint64 conn_key = 1;
inline bool PauseSendRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PauseSendRequest::set_has_conn_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PauseSendRequest::clear_has_conn_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PauseSendRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 PauseSendRequest::conn_key() const {
  // @@protoc_insertion_point(field_get:proto.PauseSendRequest.conn_key)
  return conn_key_;
}
inline void PauseSendRequest::set_conn_key(::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
  // @@protoc_insertion_point(field_set:proto.PauseSendRequest.conn_key)
}

// -------------------------------------------------------------------

// PauseSendResponse

// required .proto.ResponseCode rc = 1;
inline bool PauseSendResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PauseSendResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void PauseSendResponse::clear_has_rc() { _has_bits_[0] &= ~0x00000001u; }
inline void PauseSendResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& PauseSendResponse::_internal_rc() const {
  return *rc_;
}
inline const ::proto::ResponseCode& PauseSendResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.PauseSendResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* PauseSendResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.PauseSendResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* PauseSendResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.PauseSendResponse.rc)
  return rc_;
}
inline void PauseSendResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.PauseSendResponse.rc)
}

// -------------------------------------------------------------------

// ResumeSendRequest

// required uint64 conn_key = 1;
inline bool ResumeSendRequest::has_conn_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResumeSendRequest::set_has_conn_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResumeSendRequest::clear_has_conn_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResumeSendRequest::clear_conn_key() {
  conn_key_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_key();
}
inline ::google::protobuf::uint64 ResumeSendRequest::conn_key() const {
  // @@protoc_insertion_point(field_get:proto.ResumeSendRequest.conn_key)
  return conn_key_;
}
inline void ResumeSendRequest::set_conn_key(::google::protobuf::uint64 value) {
  set_has_conn_key();
  conn_key_ = value;
  // @@protoc_insertion_point(field_set:proto.ResumeSendRequest.conn_key)
}

// -------------------------------------------------------------------

// ResumeSendResponse

// required .proto.ResponseCode rc = 1;
inline bool ResumeSendResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResumeSendResponse::set_has_rc() { _has_bits_[0] |= 0x00000001u; }
inline void ResumeSendResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResumeSendResponse::clear_rc() {
  if (rc_ != NULL) rc_->Clear();
  clear_has_rc();
}
inline const ::proto::ResponseCode& ResumeSendResponse::_internal_rc() const {
  return *rc_;
}
inline const ::proto::ResponseCode& ResumeSendResponse::rc() const {
  const ::proto::ResponseCode* p = rc_;
  // @@protoc_insertion_point(field_get:proto.ResumeSendResponse.rc)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::proto::ResponseCode*>(
                         &::proto::_ResponseCode_default_instance_);
}
inline ::proto::ResponseCode* ResumeSendResponse::release_rc() {
  // @@protoc_insertion_point(field_release:proto.ResumeSendResponse.rc)
  clear_has_rc();
  ::proto::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}
inline ::proto::ResponseCode* ResumeSendResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) {
    auto* p = CreateMaybeMessage<::proto::ResponseCode>(GetArenaNoVirtual());
    rc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ResumeSendResponse.rc)
  return rc_;
}
inline void ResumeSendResponse::set_allocated_rc(::proto::ResponseCode* rc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rc_;
  }
  if (rc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rc = ::google::protobuf::internal::GetOwnedMessage(message_arena, rc,
                                                         submessage_arena);
    }
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_ = rc;
  // @@protoc_insertion_point(field_set_allocated:proto.ResumeSendResponse.rc)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::proto::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::proto::MessageType>() {
  return ::proto::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_2eproto
